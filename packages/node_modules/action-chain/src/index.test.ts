import {
  actionChainFactory,
  actionBaseFactory,
  ActionBase,
  NoValueActionBase,
  ActionChain,
  ExecutionContext,
} from './'

interface Operators<Context, InitialValue, Value> {
  test(
    cb: (value: Value, context: Context) => void
  ): InitialValue extends undefined
    ? NoValueAction<Context, InitialValue, Value>
    : Action<Context, InitialValue, Value>
  testFork(
    action: Action<Context, Value>
  ): InitialValue extends undefined
    ? NoValueAction<Context, InitialValue, Value>
    : Action<Context, InitialValue, Value>
}

export interface Action<Context, InitialValue, Value = InitialValue>
  extends Operators<Context, InitialValue, Value>,
    ActionBase<Context, InitialValue, Value> {}

export interface NoValueAction<Context, InitialValue, Value = InitialValue>
  extends Operators<Context, InitialValue, Value>,
    NoValueActionBase<Context, InitialValue, Value> {}

function actionFactory<Context, InitialValue, Value = InitialValue>(
  actionChain: ActionChain<Context>,
  initialActionId?: number,
  runOperators?: (
    value: any,
    executionContext: ExecutionContext
  ) => any | Promise<any>
): InitialValue extends undefined
  ? NoValueAction<Context, InitialValue, Value>
  : Action<Context, InitialValue, Value> {
  return Object.assign(
    actionBaseFactory<Context, InitialValue, Value>(
      actionChain,
      initialActionId,
      runOperators
    ) as any,
    {
      test(cb: (value: Value, context: Context) => void) {
        const operator = (value, context) => {
          return cb(value, context)
        }

        const [
          chain,
          initialActionId,
          runOperators,
        ] = this.createOperatorResult('test', cb.name, operator)

        return actionFactory<Context, InitialValue, Value>(
          chain,
          initialActionId,
          runOperators
        )
      },
      testFork(action: Action<Context, Value>) {
        const operator = (value, context) => {
          return (action as any)(value, context, 'fork')
        }

        const [
          chain,
          initialActionId,
          runOperators,
        ] = this.createOperatorResult('testFork', action.name, operator)

        return actionFactory<Context, InitialValue, Value>(
          chain,
          initialActionId,
          runOperators
        )
      },
    }
  )
}

const context = {
  foo: {
    bar() {
      return 'baz'
    },
  },
}

type Context = typeof context

const actionChain = actionChainFactory<Context>(context)
const action = function<
  InitialValue = undefined
>(): InitialValue extends undefined
  ? NoValueAction<Context, InitialValue>
  : Action<Context, InitialValue> {
  return actionFactory<Context, InitialValue>(actionChain)
}

beforeEach(() => {
  ;(actionBaseFactory as any).nextActionId = 0
})

describe('VALUE', () => {
  test('should run and return result', () => {
    const test = action<string>()

    expect(test('foo')).toEqual('foo')
  })
})

describe('CONTEXT', () => {
  test('should pass default context', () => {
    expect.assertions(2)
    const test = action().test((_, { __execution, __path }: any) => {
      expect(__execution).toBeTruthy()
      expect(__path).toBeTruthy()
    })

    test()
  })

  test('should be able to extend context', () => {
    expect.assertions(1)
    const foo = action().test((_, { foo }) => {
      expect(foo.bar()).toBe('baz')
    })

    foo()
  })
})

describe('PROVIDER', () => {
  test('should track execution of providers', () => {
    expect.assertions(2)
    const foo = action().test((_, { foo }) => {
      expect(foo.bar()).toBe('baz')
    })

    actionChain.once('provider', (task) => {
      expect(task).toEqual({
        operatorId: 0,
        actionId: 0,
        executionId: 0,
        method: 'bar',
        name: 'foo',
        result: 'baz',
      })
    })
    foo()
  })
})

describe('ACTION CHAIN', () => {
  test('should track execution', () => {
    expect.assertions(4)
    const foo = action().test(() => 'foo')

    actionChain.once('action:start', (data) => {
      expect(data).toEqual({
        actionId: 0,
        executionId: 0,
      })
    })
    actionChain.once('operator:start', (data) => {
      expect(data).toEqual({
        actionId: 0,
        executionId: 0,
        operatorId: 0,
        name: '',
        type: 'test',
        path: [],
      })
    })
    actionChain.once('operator:end', (data) => {
      expect(data).toEqual({
        actionId: 0,
        executionId: 0,
        operatorId: 0,
        name: '',
        type: 'test',
        isAsync: false,
        path: [],
        result: 'foo',
      })
    })
    actionChain.once('action:end', (data) => {
      expect(data).toEqual({
        actionId: 0,
        executionId: 0,
      })
    })

    foo()
  })
  test('should track async execution', () => {
    expect.assertions(2)
    const foo = () => {
      return Promise.resolve('foo')
    }
    const test = action().test(foo)

    actionChain.once('operator:start', (task) => {
      expect(task).toEqual({
        actionId: 0,
        operatorId: 0,
        executionId: 0,
        name: 'foo',
        path: [],
        type: 'test',
      })
    })
    actionChain.once('operator:end', (task) => {
      expect(task).toEqual({
        actionId: 0,
        operatorId: 0,
        executionId: 0,
        name: 'foo',
        path: [],
        type: 'test',
        isAsync: true,
        result: 'foo',
      })
    })

    return test()
  })
  test('should track path execution', () => {
    expect.assertions(4)
    const forkAction = action().test(() => Promise.resolve('foo'))
    const test = action().testFork(forkAction)

    actionChain.once('operator:start', (task) => {
      expect(task).toEqual({
        actionId: 1,
        operatorId: 0,
        executionId: 0,
        name: '',
        path: [],
        type: 'testFork',
      })
      actionChain.once('operator:start', (task) => {
        expect(task).toEqual({
          actionId: 1,
          operatorId: 1,
          executionId: 0,
          name: '',
          path: ['fork'],
          type: 'test',
        })
      })
    })
    actionChain.once('operator:end', (task) => {
      expect(task).toEqual({
        actionId: 1,
        operatorId: 1,
        executionId: 0,
        name: '',
        path: ['fork'],
        type: 'test',
        isAsync: true,
        result: 'foo',
      })
      actionChain.once('operator:end', (task) => {
        expect(task).toEqual({
          actionId: 1,
          operatorId: 0,
          executionId: 0,
          name: '',
          path: [],
          type: 'testFork',
          isAsync: true,
          result: 'foo',
        })
      })
    })

    return test()
  })
  test('should emit event when operator has async result', () => {
    expect.assertions(1)
    const test = action().test(() => Promise.resolve('foo'))

    actionChain.once('operator:async', (task) => {
      expect(task).toEqual({
        actionId: 0,
        operatorId: 0,
        executionId: 0,
        name: '',
        path: [],
        isAsync: true,
        type: 'test',
      })
    })

    return test()
  })
})
