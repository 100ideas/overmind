import { EventEmitter } from 'betsy'

const IS_DEVELOPMENT = process.env.NODE_ENV !== 'production'

export type Execution = {
  operatorId: number
  actionId: number
  executionId: number
}

export type ExecutionContext = {
  __execution: Execution
  __path: string[]
}

export type ActionExecution = {
  actionId: number
  executionId: number
  actionName: string
  value?: any
}

type OperatorExecution = {
  actionId: number
  executionId: number
  operatorId: number
  type: string
  name: string
  path: string
}

interface ActionChainEvents {
  effect: Execution & {
    name: string
    method: string | number | symbol
    result: any
    args: any[]
  }
  'action:start': ActionExecution
  'action:end': ActionExecution
  'operator:start': OperatorExecution
  'operator:async': OperatorExecution & {
    isAsync: boolean
  }
  'operator:end': OperatorExecution & {
    isAsync: boolean
    result: any
  }
}

function isObject(value) {
  return typeof value === 'object' && !Array.isArray(value) && value !== null
}

export class ActionChain<Effects, ExtraEvents = {}> extends EventEmitter<
  ActionChainEvents & ExtraEvents
> {
  constructor(
    private effects: Effects,
    private options: { providerExceptions?: string[] } = {}
  ) {
    super()
    this.options.providerExceptions = options.providerExceptions || []
  }
  private createGetHandler(execution: Execution, path: string) {
    return (target, prop) => {
      if (typeof target[prop] === 'function') {
        return (...args) => {
          const result = target[prop](...args)
          if (result instanceof Promise) {
            result.then((promisedResult) => {
              this.emitAsync('effect', {
                ...execution,
                name: path,
                method: prop,
                args,
                result: promisedResult,
              })
            })
          } else {
            this.emitAsync('effect', {
              ...execution,
              name: path,
              method: prop,
              args,
              result,
            })
          }

          return result
        }
      } else if (isObject(target[prop])) {
        return new Proxy(target[prop], {
          get: this.createGetHandler(execution, path + '.' + prop),
        })
      }

      return target[prop]
    }
  }

  getEffects(thisExecution: Execution, executionContext: ExecutionContext) {
    let effects = this.effects

    if (IS_DEVELOPMENT) {
      effects = Object.keys(this.effects).reduce(
        (currentEffects, key) => {
          if (
            this.options.providerExceptions.indexOf(key) === -1 &&
            isObject(this.effects[key])
          ) {
            currentEffects[key] = new Proxy(this.effects[key], {
              get: this.createGetHandler(thisExecution, key),
            })
          } else {
            currentEffects[key] = this.effects[key]
          }

          return currentEffects
        },
        {} as Effects
      )
    }

    return Object.assign({}, effects, executionContext)
  }
}
