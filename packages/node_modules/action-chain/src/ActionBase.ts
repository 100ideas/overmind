import { ActionChain, Execution, ExecutionContext } from './ActionChain'
;(actionBaseFactory as any).nextActionId = 0

export class StopExecution {
  value: any
  constructor(value) {
    this.value = value
  }
}

export interface ActionBase<Context, InitialValue, Value = InitialValue> {
  (value: InitialValue): Value
  createOperatorResult(
    type: string,
    name: string,
    cb: any
  ): [ActionChain<Context>, number, any]
}

export interface NoValueActionBase<Context, InitialValue, Value = InitialValue>
  extends ActionBase<Context, InitialValue, Value> {
  (): Value
}

export function actionBaseFactory<
  Context,
  InitialValue,
  Value = InitialValue,
  ReturnAction = InitialValue extends undefined
    ? NoValueActionBase<Context, InitialValue, Value>
    : ActionBase<Context, InitialValue, Value>
>(
  actionChain: ActionChain<Context>,
  initialActionId: number = (actionBaseFactory as any).nextActionId++,
  runOperators?: (
    value: any,
    executionContext: {
      __execution: Execution
      __path: string[]
    },
    newPath?: string
  ) => any | Promise<any>
): ReturnAction {
  let currentExecutionId = 0
  return Object.assign(
    function(value) {
      const initialOperator = typeof arguments[1] === 'undefined'
      const newPath = typeof arguments[2] === 'undefined' ? null : arguments[2]
      const executionContext: ExecutionContext = initialOperator
        ? {
            __execution: {
              operatorId: -1,
              actionId: initialActionId,
              executionId: currentExecutionId++,
            },
            __path: [],
          }
        : arguments[1]
      if (initialOperator) {
        actionChain.emit('action:start', {
          actionId: executionContext.__execution.actionId,
          executionId: executionContext.__execution.executionId,
        })
      }
      const returnValue = runOperators
        ? runOperators(value, executionContext, newPath)
        : value

      if (initialOperator && returnValue instanceof Promise) {
        returnValue.then(() => {
          actionChain.emit('action:end', {
            actionId: executionContext.__execution.actionId,
            executionId: executionContext.__execution.executionId,
          })
        })
      } else if (initialOperator) {
        actionChain.emit('action:end', {
          actionId: executionContext.__execution.actionId,
          executionId: executionContext.__execution.executionId,
        })
      }

      return returnValue
    } as any,
    {
      createOperatorResult(
        type: string,
        name: string,
        cb: any
      ): [ActionChain<Context>, number, any] {
        return [
          actionChain,
          initialActionId,
          (props, executionContext, newPath) => {
            const executionContextWithPath = {
              __execution: executionContext.__execution,
              __path: newPath
                ? executionContext.__path.concat(newPath)
                : executionContext.__path.slice(),
            }
            const path = executionContextWithPath.__path
            const prevResult = runOperators
              ? runOperators(props, executionContextWithPath)
              : props

            const operatorId = ++executionContextWithPath.__execution.operatorId

            function produceResult(currentValue) {
              if (currentValue instanceof StopExecution) {
                return currentValue.value
              }

              const context = actionChain.getContext(executionContextWithPath)

              actionChain.emit('operator:start', {
                type,
                name,
                path,
                ...context.__execution,
                operatorId,
              })
              const result = cb(currentValue, context)

              if (result instanceof Promise) {
                actionChain.emit('operator:async', {
                  type,
                  name,
                  path,
                  isAsync: true,
                  ...context.__execution,
                  operatorId,
                })
                return result.then((promiseResult) => {
                  actionChain.emit('operator:end', {
                    type,
                    name,
                    path,
                    ...context.__execution,
                    isAsync: true,
                    result: promiseResult,
                    operatorId,
                  })
                  return promiseResult
                })
              }

              actionChain.emit('operator:end', {
                type,
                name,
                path,
                ...context.__execution,
                isAsync: false,
                result: result,
                operatorId,
              })

              return result
            }

            if (prevResult instanceof Promise) {
              return prevResult.then(produceResult)
            }

            return produceResult(prevResult)
          },
        ]
      },
    }
  )
}
