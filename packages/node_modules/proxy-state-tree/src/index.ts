import { IS_PROXY, VALUE, PATH, Proxifier } from './Proxyfier'
import * as isPlainObject from 'is-plain-obj'
import {
  IMutation,
  ITrackMutationTree,
  IMutationCallback,
  ITrackCallback,
  ITrackStateTree,
  TTree,
  IOptions,
  IProxyStateTree,
  IFlushCallback,
  IProxifier,
} from './types'
import { TrackMutationTree } from './TrackMutationTree'
import { TrackStateTree } from './TrackStateTree'
const IS_PRODUCTION = process.env.NODE_ENV === 'production'

export {
  IS_PROXY,
  VALUE,
  PATH,
  IMutation,
  ITrackCallback,
  ITrackStateTree,
  ITrackMutationTree,
  TrackStateTree,
  TrackMutationTree,
}

export * from './types'

export class ProxyStateTree<T extends object> implements IProxyStateTree<T> {
  private mutationCallbacks: IMutationCallback[] = []
  private flushCallbacks: IFlushCallback[] = []
  private cache = {
    trackMutationTree: [] as ITrackMutationTree<T>[],
    trackStateAccessTree: [] as ITrackStateTree<T>[],
  }
  currentFlushId: number = 0
  currentTree: TTree
  previousTree: TTree
  mutationTree: ITrackMutationTree<T>
  proxifier: IProxifier<T>
  master: ProxyStateTree<T>
  mutations: IMutation[] = []
  objectChanges = new Set<string>()
  pathDependencies: {
    [path: string]: Set<ITrackCallback>
  } = {}
  state: T
  sourceState: T
  options: IOptions
  constructor(state: T, options: IOptions = {}) {
    if (!isPlainObject(state)) {
      throw new Error(
        'You did not pass a plain object as state to Proxy State Tree'
      )
    }

    if (typeof options.devmode === 'undefined') {
      options.devmode = true
    }

    this.master = this
    this.sourceState = state
    this.options = options

    this.createTrackStateProxifier()
  }
  /*
    We create a base proxifier for tracking state. That means there is one
    proxifier for all track state trees. This works because the actual tracking
    refers to the current tree on "master"
  */
  private createTrackStateProxifier() {
    const trackStateTree = new TrackStateTree(this)

    this.proxifier = trackStateTree.proxifier = new Proxifier(trackStateTree)
    this.state = trackStateTree.state = this.proxifier.proxify(
      this.sourceState,
      ''
    )
  }
  getMutationTree(): ITrackMutationTree<T> {
    if (IS_PRODUCTION) {
      return (this.mutationTree =
        this.mutationTree || new TrackMutationTree(this, this.proxifier))
    }

    const tree =
      this.cache.trackMutationTree.pop() || new TrackMutationTree(this)

    return tree
  }
  getTrackStateTree(): ITrackStateTree<T> {
    const tree =
      this.cache.trackStateAccessTree.pop() || new TrackStateTree(this)

    return tree
  }
  changeTrackStateTree(tree: ITrackStateTree<T>) {
    this.previousTree = this.currentTree
    this.currentTree = tree
  }
  disposeTree(tree: TTree) {
    if (tree instanceof TrackMutationTree) {
      this.cache.trackMutationTree.push(tree.dispose())
    } else if (tree instanceof TrackStateTree) {
      this.cache.trackStateAccessTree.push(tree.dispose())
    }
  }
  onMutation(callback: IMutationCallback) {
    this.mutationCallbacks.push(callback)
  }
  onFlush(callback: IFlushCallback) {
    this.flushCallbacks.push(callback)
  }
  addMutation(mutation: IMutation, objectChangePath?: string) {
    this.mutations.push(mutation)

    if (objectChangePath) {
      this.objectChanges.add(objectChangePath)
    }

    for (let cb of this.mutationCallbacks) {
      cb(
        mutation,
        new Set(
          objectChangePath ? [mutation.path, objectChangePath] : [mutation.path]
        ),
        this.currentFlushId
      )
    }
  }
  rescope(value: any, tree: TTree) {
    return value && value[IS_PROXY]
      ? tree.proxifier.proxify(value[VALUE], value[PATH])
      : value
  }
  addPathDependency(path: string, callback: ITrackCallback) {
    if (!this.pathDependencies[path]) {
      this.pathDependencies[path] = new Set()
    }

    this.pathDependencies[path].add(callback)
  }
  removePathDependency(path: string, callback: ITrackCallback) {
    this.pathDependencies[path].delete(callback)

    if (!this.pathDependencies[path].size) {
      delete this.pathDependencies[path]
    }
  }
  flush(isAsync: boolean = false) {
    const paths = new Set()
    const pathCallbacksToCall = new Set()
    const mutations = this.mutations.slice()
    const flushId = this.currentFlushId++

    for (let objectChange of this.objectChanges) {
      if (this.pathDependencies[objectChange]) {
        paths.add(objectChange)
      }
    }

    for (let mutation of mutations) {
      paths.add(mutation.path)
    }

    // Sort so that parent paths are called first
    const sortedPaths = Array.from(paths).sort()

    for (let path of sortedPaths) {
      if (this.pathDependencies[path]) {
        for (let callback of this.pathDependencies[path]) {
          pathCallbacksToCall.add(callback)
        }
      }
    }

    for (let callback of pathCallbacksToCall) {
      callback(mutations, sortedPaths, flushId, isAsync)
    }

    for (let callback of this.flushCallbacks) {
      callback(mutations, sortedPaths, flushId, isAsync)
    }

    paths.clear()
    pathCallbacksToCall.clear()
    this.mutations.length = 0
    this.objectChanges.clear()

    return {
      mutations,
      flushId,
    }
  }
  toJSON() {
    return this.sourceState
  }
}
