import { IS_PROXY, VALUE, PATH, Proxifier } from './Proxyfier'
import {
  TrackMutationTree,
  IMutation,
  ITrackMutationTree,
  IMutationCallback,
} from './TrackMutationTree'
import {
  TrackStateTree,
  ITrackCallback,
  ITrackStateTree,
} from './TrackStateTree'
const isPlainObject = require('is-plain-object')
const IS_PRODUCTION = process.env.NODE_ENV === 'production'

export {
  IS_PROXY,
  VALUE,
  PATH,
  IMutation,
  ITrackCallback,
  ITrackStateTree,
  ITrackMutationTree,
  TrackStateTree,
  TrackMutationTree,
}

export interface IOptions {
  devmode?: boolean
  dynamicWrapper?: Function
}

export interface IFlushCallback {
  (
    mutations: IMutation[],
    paths: string[],
    flushId: number,
    isAsync: boolean
  ): void
}

export type TTree =
  | ITrackMutationTree<any>
  | ITrackStateTree<any>
  | IProxyStateTree<any>

interface IProxiesCache {
  [path: string]: Map<TTree, any>
}

export interface IProxyStateTree<T> {
  addProxy(path: string, tree: TTree, proxy: any): void
  getProxy(path: string, tree: TTree): any
  addMutation(mutation: IMutation, objectChangePath?: string): void
  addPathDependency(path: string, callback: ITrackCallback): void
  removePathDependency(path: string, callback: ITrackCallback): void
  disposeTree(proxy: TTree): void
  onMutation(cb: IMutationCallback): void
  onFlush(cb: IFlushCallback): void
  rescope(value: any, tree: TTree): any
  canMutate(): boolean
  canTrack(): boolean
  state: T
  options: IOptions
  pathDependencies: {
    [path: string]: Set<ITrackCallback>
  }
  objectChanges: Set<string>
  master: IProxyStateTree<T>
  proxifier: Proxifier
  currentTree: TTree
  currentFlushId: number
}

const removeProxyMutations = ['set', 'splice', 'shift', 'unshift']

export class ProxyStateTree<T extends object> implements IProxyStateTree<T> {
  private proxiesCache: IProxiesCache = {}
  private mutationCallbacks: IMutationCallback[] = []
  private flushCallbacks: IFlushCallback[] = []
  private cache = {
    trackMutationTree: [] as ITrackMutationTree<T>[],
    trackStateAccessTree: [] as ITrackStateTree<T>[],
  }
  currentFlushId: number = 0
  currentTree: TTree
  proxifier: Proxifier
  master: ProxyStateTree<T>
  mutations: IMutation[] = []
  objectChanges = new Set<string>()
  pathDependencies: {
    [path: string]: Set<ITrackCallback>
  } = {}
  state: T
  sourceState: object
  options: IOptions
  constructor(state: T, options: IOptions = {}) {
    if (!isPlainObject(state)) {
      throw new Error(
        'You did not pass a plain object as state to Proxy State Tree'
      )
    }

    if (typeof options.devmode === 'undefined') {
      options.devmode = true
    }

    this.master = this
    this.proxifier = new Proxifier(this)
    this.sourceState = state
    this.state = this.proxifier.proxify(state, '')
    this.options = options

    this.mutationCallbacks.push(this.removeProxies)
  }
  private removeProxies = (mutation: IMutation) => {
    if (removeProxyMutations.includes(mutation.method)) {
      for (let path in this.proxiesCache) {
        if (path.indexOf(mutation.path) === 0) {
          delete this.proxiesCache[path]
        }
      }
    }
  }
  canMutate() {
    return false
  }
  canTrack() {
    return false
  }
  getMutationTree(): ITrackMutationTree<T> {
    const tree =
      this.cache.trackMutationTree.pop() || new TrackMutationTree(this)

    return tree
  }
  getTrackStateTree(): ITrackStateTree<T> {
    const tree =
      this.cache.trackStateAccessTree.pop() || new TrackStateTree(this)

    return tree
  }
  disposeTree(tree: TTree) {
    if (tree instanceof TrackMutationTree) {
      this.cache.trackMutationTree.push(tree.dispose())
    } else if (tree instanceof TrackStateTree) {
      this.cache.trackStateAccessTree.push(tree.dispose())
    }
  }
  addProxy(path: string, tree: TTree, proxy: any) {
    if (!this.proxiesCache[path]) {
      this.proxiesCache[path] = new Map()
    }

    this.proxiesCache[path].set(tree, proxy)

    return proxy
  }
  getProxy(path: string, tree: TTree) {
    return this.proxiesCache[path] && this.proxiesCache[path].get(tree)
  }
  onMutation(callback: IMutationCallback) {
    this.mutationCallbacks.push(callback)
  }
  onFlush(callback: IFlushCallback) {
    this.flushCallbacks.push(callback)
  }
  addMutation(mutation: IMutation, objectChangePath?: string) {
    this.mutations.push(mutation)

    if (objectChangePath) {
      this.objectChanges.add(objectChangePath)
    }

    for (let cb of this.mutationCallbacks) {
      cb(
        mutation,
        new Set(
          objectChangePath ? [mutation.path, objectChangePath] : [mutation.path]
        ),
        this.currentFlushId
      )
    }
  }
  rescope(value: any, tree: TTree) {
    return value && value[IS_PROXY]
      ? tree.proxifier.proxify(value[VALUE], value[PATH])
      : value
  }
  addPathDependency(path: string, callback: ITrackCallback) {
    if (!this.pathDependencies[path]) {
      this.pathDependencies[path] = new Set()
    }

    this.pathDependencies[path].add(callback)
  }
  removePathDependency(path: string, callback: ITrackCallback) {
    this.pathDependencies[path].delete(callback)

    if (!this.pathDependencies[path].size) {
      delete this.pathDependencies[path]
    }
  }
  flush(isAsync: boolean = false) {
    const paths = new Set()
    const pathCallbacksToCall = new Set()
    const mutations = this.mutations.slice()
    const flushId = this.currentFlushId++

    for (let objectChange of this.objectChanges) {
      if (this.pathDependencies[objectChange]) {
        paths.add(objectChange)
      }
    }

    for (let mutation of mutations) {
      paths.add(mutation.path)
    }

    // Sort so that parent paths are called first
    const sortedPaths = Array.from(paths).sort()

    for (let path of sortedPaths) {
      if (this.pathDependencies[path]) {
        for (let callback of this.pathDependencies[path]) {
          pathCallbacksToCall.add(callback)
        }
      }
    }

    for (let callback of pathCallbacksToCall) {
      callback(mutations, sortedPaths, flushId, isAsync)
    }

    for (let callback of this.flushCallbacks) {
      callback(mutations, sortedPaths, flushId, isAsync)
    }

    paths.clear()
    pathCallbacksToCall.clear()
    this.mutations.length = 0
    this.objectChanges.clear()

    return {
      mutations,
      flushId,
    }
  }
  toJSON() {
    return this.sourceState
  }
}
