import { IS_PROXY, VALUE, PATH, STATUS, scopeState } from './proxify'
import { TrackMutationTree, IMutation } from './TrackMutationTree'
import { TrackStateAccessTree, ITrackCallback } from './TrackStateAcessTree'
const PROXIES = Symbol('proxies')
const isPlainObject = require('is-plain-object')
const IS_PRODUCTION = process.env.NODE_ENV === 'production'

export interface IOptions {
  devmode?: boolean
  dynamicWrapper?: Function
}

export interface IMutationCallback {
  (mutation: IMutation, paths: Set<string>, flushId: number): void
}

let hasWarnedFlushWhileTracking = false

type TTree = TrackMutationTree<any> | TrackStateAccessTree<any>

interface IProxiesCache {
  [PROXIES]?: Map<TTree, any>
  [key: string]: IProxiesCache
}

export interface IProxyStateTree {
  addProxy(path: string[], tree: TTree, proxy: any): void
  getProxy(path: string[], tree: TTree): any
  removeProxy(path: string[], tree: TTree): void
  addMutation(mutation: IMutation, paths: Set<string>): void
  addPathDependency(path: string, callback: ITrackCallback): void
}

export class ProxyStateTree<T extends object> implements IProxyStateTree {
  private pathDependencies: object = {}
  private globalDependencies = new Set<Function>()
  private proxiesCache: IProxiesCache = {}
  private mutationCallbacks: IMutationCallback[] = []
  private currentFlushId: number = 0
  private objectChanges = new Set<string>()
  private currentMutations: IMutation[] = []
  private mutations: IMutation[] = []
  private currentTree: TTree = null
  constructor(private state: T, private options: IOptions = {}) {
    if (!isPlainObject(state)) {
      throw new Error(
        'You did not pass a plain object as state to Proxy State Tree'
      )
    }

    if (typeof options.devmode === 'undefined') {
      options.devmode = true
    }
  }
  trackMutations() {
    return new TrackMutationTree(this.state)
  }
  trackStateAccess() {
    return new TrackStateAccessTree(this.state)
  }
  addProxy(path: string[], tree: TTree, proxy: any) {
    return path.reduce((aggr, key, index, array) => {
      aggr[key] = aggr[key] || {}

      if (index === array.length - 1) {
        aggr[key][PROXIES] = aggr[key][PROXIES]
          ? aggr[key][PROXIES].set(tree, proxy)
          : new Map([[tree, proxy]])
      }

      return aggr[key]
    }, this.proxiesCache)[PROXIES]
  }
  getProxy(path: string[], tree: TTree) {
    const target = path.reduce(
      (aggr, key) => (aggr ? aggr[key] : aggr),
      this.proxiesCache
    )

    return target ? target[PROXIES].get(tree) : null
  }
  removeProxy(path: string[], tree: TTree) {
    const target = path.reduce(
      (aggr, key) => (aggr ? aggr[key] : aggr),
      this.proxiesCache
    )

    target && target[PROXIES] && target[PROXIES].clear()
  }
  addMutation(mutation: IMutation) {
    const paths = new Set([...this.objectChanges, mutation.path])

    this.currentMutations.push(mutation)

    for (let cb of this.mutationCallbacks) {
      cb(mutation, paths, this.currentFlushId + 1)
    }
  }
  addPathDependency(path: string, callback: ITrackCallback) {
    if (!this.pathDependencies[path]) {
      this.pathDependencies[path] = new Set()
    }

    this.pathDependencies[path].add(callback)
  }
  flush(isAsync: boolean = false) {
    const paths = new Set()
    const pathCallbacksToCall = new Set()
    const mutations = this.mutations.slice()
    const flushId = this.currentFlushId++

    for (let objectChange of this.objectChanges) {
      if (this.pathDependencies[objectChange]) {
        paths.add(objectChange)
      }
    }

    for (let mutation of mutations) {
      paths.add(mutation.path)
    }

    // Sort so that parent paths are called first
    const sortedPaths = Array.from(paths).sort()

    for (let path of sortedPaths) {
      if (this.pathDependencies[path]) {
        for (let callback of this.pathDependencies[path]) {
          pathCallbacksToCall.add(callback)
        }
      }
    }

    for (let callback of pathCallbacksToCall) {
      callback(flushId, isAsync)
    }

    paths.clear()
    pathCallbacksToCall.clear()
    this.mutations.length = 0
    this.objectChanges.clear()

    for (let globalDependency of this.globalDependencies) {
      globalDependency(mutations, flushId, isAsync)
    }

    return {
      mutations,
      flushId,
    }
  }
}
/*
export class ProxyStateTree {
  
  private parentTree: ProxyStateTree
  private status: Set<STATUS> = new Set()
  private completedTrackingCallbacks = []
  
  private proxies: any = {}
  private children: any[] = []
  private proxy: any
  private trackCb: any
  private PROXY = Symbol('TREE_INSTANCE')
  constructor(private state: object, private options: Options = {}) {

  }

  get() {
    return this.proxy
  }
  getScopedTree() {
    const instance = new ProxyStateTree(this.state, this.options)
    instance.parentTree = this

    this.children.push(instance)

    return instance
  }
  scope(value) {
    return value && value[IS_PROXY]
      ? scopeState(this, value[VALUE], value[PATH])
      : value
  }
  startMutationTracking() {
    this.status.add(STATUS.TRACKING_MUTATIONS)
  }
  clearMutationTracking() {
    const currentMutations = this.currentMutations.slice()

    this.status.delete(STATUS.TRACKING_MUTATIONS)
    this.currentMutations.length = 0
    this.mutations = this.mutations.concat(currentMutations)

    return currentMutations
  }
  startPathsTracking() {
    this.status.add(STATUS.TRACKING_PATHS)

    return this.paths.push(new Set()) - 1
  }
  clearPathsTracking(index: number, cb?: () => void) {
    const pathSet = this.paths.splice(index, 1, null)[0]

    while (this.paths[this.paths.length - 1] === null) {
      this.paths.pop()
    }


    return pathSet
  }
  track(cb) {
    console.log('Tracking!')
    this.status.add(STATUS.TRACKING_PATHS)
    const set = new Set()
    this.paths.push(set)
    this.trackCb = cb
  }
  addMutationListener(cb: MutationCallback) {
    const index = this.mutationCallbacks.push(cb) - 1

    return () => {
      this.mutationCallbacks.splice(index, 1)
    }
  }
  addFlushListener(cb: (mutations: Mutation[], flushId: number) => void)
  addFlushListener(initialPaths: Set<string>, cb: (flushId: number) => void)
  addFlushListener() {
    if (arguments.length === 1) {
      const cb = arguments[0]
      const globalDependencies = this.globalDependencies
      globalDependencies.add(cb)

      return {
        dispose() {
          globalDependencies.delete(cb)
        },
      }
    } else {
      const tree = this.parentTree || this
      const initialPaths = arguments[0]
      const cb = arguments[1]
      const pathDependencies = tree.pathDependencies
      let currentStringPaths = initialPaths

      for (let currentStringPath of currentStringPaths) {
        pathDependencies[currentStringPath] = pathDependencies[
          currentStringPath
        ]
          ? pathDependencies[currentStringPath].add(cb)
          : new Set([cb])
      }

      return {
        update(newStringPaths: Set<string>) {
          for (let currentStringPath of currentStringPaths) {
            if (!newStringPaths.has(currentStringPath)) {
              pathDependencies[currentStringPath].delete(cb)
            }
          }

          for (let newStringPath of newStringPaths) {
            if (!currentStringPaths.has(newStringPath)) {
              pathDependencies[newStringPath] = pathDependencies[newStringPath]
                ? pathDependencies[newStringPath].add(cb)
                : new Set([cb])
            }
          }

          currentStringPaths = newStringPaths
        },
        dispose() {
          for (let currentStringPath of currentStringPaths) {
            pathDependencies[currentStringPath].delete(cb)

            if (pathDependencies[currentStringPath].size === 0) {
              delete pathDependencies[currentStringPath]
            }
          }
        },
      }
    }
  }
}
*/
export { IS_PROXY, VALUE, PATH }
