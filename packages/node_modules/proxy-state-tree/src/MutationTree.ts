import {
  IProxyStateTree,
  IMutationTree,
  IMutationCallback,
  IMutation,
  IProxifier,
} from './types'
import { Proxifier } from './Proxyfier'

export class MutationTree<T extends object> implements IMutationTree<T> {
  private mutationCallbacks: IMutationCallback[] = []
  master: IProxyStateTree<T>
  state: T
  proxifier: IProxifier<T>
  isTracking: boolean = false
  constructor(master: IProxyStateTree<T>, proxifier?: IProxifier<T>) {
    this.isTracking = true
    this.master = master
    this.proxifier = proxifier || new Proxifier(this)
    this.state = this.proxifier.proxify(master.sourceState, '')
  }
  addMutation(mutation: IMutation, objectChangePath: string) {
    this.master.addMutation(mutation, objectChangePath)

    for (let callback of this.mutationCallbacks) {
      callback(
        mutation,
        new Set(
          objectChangePath ? [mutation.path, objectChangePath] : [mutation.path]
        ),
        this.master.currentFlushId
      )
    }
  }
  onMutation(callback: IMutationCallback) {
    this.mutationCallbacks.push(callback)
  }
  canMutate() {
    return this.isTracking
  }
  canTrack() {
    return false
  }
  dispose() {
    this.isTracking = false
    this.mutationCallbacks.length = 0
    return this
  }
}
