const isPlainObject = require('is-plain-object')

export const IS_PROXY = Symbol('IS_PROXY')
export const PATH = Symbol('PATH')
export const VALUE = Symbol('VALUE')

export enum STATUS {
  TRACKING_PATHS = 'TRACKING_PATHS',
  TRACKING_MUTATIONS = 'TRACKING_MUTATIONS',
}

const arrayMutations = new Set([
  'push',
  'shift',
  'pop',
  'unshift',
  'splice',
  'reverse',
  'sort',
  'copyWithin',
])

function concat(path, prop) {
  return path === undefined ? prop : path + '.' + prop
}

function shouldTrackMutations(tree, path) {
  return tree.options.devmode || (path && tree.pathDependencies[path])
}

function ensureMutationTrackingIsEnabled(tree, path) {
  if (tree.options.devmode && !tree.status.has(STATUS.TRACKING_MUTATIONS)) {
    throw new Error(
      `proxy-state-tree - You are mutating the path "${path}", but it is not allowed`
    )
  }
}

function ensureValueDosntExistInStateTreeElsewhere(value) {
  if (value && value[IS_PROXY] === true) {
    throw new Error(
      `proxy-state-tree - You are trying to insert a value that already exists in the state tree on path "${
        value[PATH]
      }"`
    )
  }
}

function trackPath(tree, path) {
  if (tree.status.has(STATUS.TRACKING_PATHS)) {
    tree.addTrackingPath(path)
  }
}

export function scopeState(tree, state, initialPath = '') {
  function proxify(value, path) {
    if (value) {
      if (value[IS_PROXY] && value[PATH] !== path) {
        return proxify(value[VALUE], path)
      } else if (value[IS_PROXY]) {
        return value
      } else if (isPlainObject(value)) {
        return createObjectProxy(value, path)
      } else if (Array.isArray(value)) {
        return createArrayProxy(value, path)
      }
    }
    return value
  }

  function createArrayProxy(value, path) {
    return (
      tree.getProxy(path) ||
      tree.addProxy(
        path,
        new Proxy(value, {
          get(target, prop) {
            if (prop === IS_PROXY) return true
            if (prop === PATH) return path
            if (prop === VALUE) return value

            if (
              prop === 'length' ||
              (typeof target[prop] === 'function' &&
                !arrayMutations.has(String(prop))) ||
              typeof prop === 'symbol'
            ) {
              return target[prop]
            }

            const nestedPath = concat(path, prop)
            trackPath(tree, nestedPath)

            if (
              arrayMutations.has(String(prop)) &&
              shouldTrackMutations(tree, nestedPath)
            ) {
              ensureMutationTrackingIsEnabled(tree, nestedPath)
              return (...args) => {
                tree.addMutation({
                  method: prop,
                  path: path,
                  args: args,
                })

                return target[prop](...args)
              }
            }

            if (target[prop] === undefined) {
              return undefined
            }

            return proxify(target[prop], nestedPath)
          },
          set(target, prop, value) {
            const nestedPath = concat(path, prop)

            ensureMutationTrackingIsEnabled(tree, nestedPath)
            ensureValueDosntExistInStateTreeElsewhere(value)

            tree.addMutation({
              method: 'set',
              path: nestedPath,
              args: [value],
            })

            tree.removeProxy(nestedPath)

            return Reflect.set(target, prop, value)
          },
        })
      )
    )
  }

  function createObjectProxy(value, path) {
    return (
      tree.getProxy(path) ||
      tree.addProxy(
        path,
        new Proxy(value, {
          get(target, prop) {
            if (prop === IS_PROXY) return true
            if (prop === PATH) return path
            if (prop === VALUE) return value

            if (typeof prop === 'symbol' || prop in Object.prototype)
              return target[prop]

            const targetValue = target[prop]
            const nestedPath = concat(path, prop)
            trackPath(tree, nestedPath)

            if (typeof targetValue === 'function') {
              const dynamicValue = tree.options.dynamicWrapper
                ? tree.options.dynamicWrapper(tree, nestedPath, targetValue)
                : targetValue(tree, nestedPath)

              if (dynamicValue && dynamicValue[IS_PROXY]) {
                return proxify(dynamicValue[VALUE], dynamicValue[PATH])
              }

              return dynamicValue
            }

            if (targetValue === undefined) {
              return undefined
            }

            return proxify(targetValue, nestedPath)
          },
          set(target, prop, value) {
            const nestedPath = concat(path, prop)

            ensureMutationTrackingIsEnabled(tree, nestedPath)
            ensureValueDosntExistInStateTreeElsewhere(value)

            if (shouldTrackMutations(tree, nestedPath)) {
              if (!(prop in target)) {
                tree.objectChanges.add(path)
              }

              tree.addMutation({
                method: 'set',
                path: nestedPath,
                args: [value],
              })
            }

            if (typeof value === 'function') {
              return Reflect.set(target, prop, () => value)
            }

            tree.removeProxy(nestedPath)

            return Reflect.set(target, prop, value)
          },
          deleteProperty(target, prop) {
            const nestedPath = concat(path, prop)

            ensureMutationTrackingIsEnabled(tree, nestedPath)

            if (shouldTrackMutations(tree, nestedPath)) {
              if (prop in target) {
                tree.objectChanges.add(path)
              }

              tree.addMutation({
                method: 'unset',
                path: nestedPath,
                args: [],
              })
            }

            delete target[prop]

            tree.removeProxy(nestedPath)

            return true
          },
        })
      )
    )
  }

  return proxify(state, initialPath)
}
