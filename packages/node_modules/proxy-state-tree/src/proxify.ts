const isPlainObject = require('is-plain-object')
const IS_PRODUCTION = process.env.NODE_ENV === 'production'

export const IS_PROXY = Symbol('IS_PROXY')
export const PATH = Symbol('PATH')
export const VALUE = Symbol('VALUE')

export enum STATUS {
  TRACKING_PATHS = 'TRACKING_PATHS',
  TRACKING_MUTATIONS = 'TRACKING_MUTATIONS',
}

const arrayMutations = new Set([
  'push',
  'shift',
  'pop',
  'unshift',
  'splice',
  'reverse',
  'sort',
  'copyWithin',
])

function concat(path, prop) {
  return path === undefined ? prop : path + '.' + prop
}

function shouldTrackMutations(tree, path) {
  return tree.options.devmode || (path && tree.pathDependencies[path])
}

function ensureMutationTrackingIsEnabled(tree, path) {
  if (!tree.status.has(STATUS.TRACKING_MUTATIONS)) {
    throw new Error(
      `proxy-state-tree - You are mutating the path "${path}", but it is not allowed`
    )
  }
}

function ensureValueDosntExistInStateTreeElsewhere(value) {
  if (value && value[IS_PROXY] === true) {
    throw new Error(
      `proxy-state-tree - You are trying to insert a value that already exists in the state tree on path "${
        value[PATH]
      }"`
    )
  }
}

function trackPath(tree, path) {
  if (tree.status.has(STATUS.TRACKING_PATHS)) {
    tree.paths[tree.paths.length - 1].add(path)
  }
}

function createArrayProxy(tree, value, path) {
  return new Proxy(value, {
    get(target, prop) {
      if (prop === IS_PROXY) return true
      if (prop === PATH) return path
      if (prop === VALUE) return value

      if (
        prop === 'length' ||
        (typeof target[prop] === 'function' &&
          !arrayMutations.has(String(prop))) ||
        typeof prop === 'symbol'
      ) {
        return target[prop]
      }

      const nestedPath = concat(path, prop)
      trackPath(tree, nestedPath)

      if (
        arrayMutations.has(String(prop)) &&
        shouldTrackMutations(tree, nestedPath)
      ) {
        ensureMutationTrackingIsEnabled(tree, nestedPath)
        return (...args) => {
          tree.addMutation({
            method: prop,
            path: path,
            args: args,
          })

          return target[prop](...args)
        }
      }

      if (target[prop] === undefined) {
        return undefined
      }

      return proxify(tree, target[prop], nestedPath)
    },
    set(target, prop, value) {
      const nestedPath = concat(path, prop)

      ensureMutationTrackingIsEnabled(tree, nestedPath)
      ensureValueDosntExistInStateTreeElsewhere(value)

      tree.addMutation({
        method: 'set',
        path: nestedPath,
        args: [value],
      })

      return Reflect.set(target, prop, value)
    },
  })
}

function createObjectProxy(tree, value, path) {
  return new Proxy(value, {
    get(target, prop) {
      if (prop === IS_PROXY) return true
      if (prop === PATH) return path
      if (prop === VALUE) return value

      if (typeof prop === 'symbol' || prop in Object.prototype)
        return target[prop]

      const targetValue = target[prop]
      const nestedPath = concat(path, prop)
      trackPath(tree, nestedPath)

      if (typeof targetValue === 'function') {
        return tree.options.dynamicWrapper
          ? tree.options.dynamicWrapper(tree, nestedPath, targetValue)
          : targetValue(tree, nestedPath)
      }

      if (targetValue === undefined) {
        return undefined
      }

      return proxify(tree, targetValue, nestedPath)
    },
    set(target, prop, value) {
      const nestedPath = concat(path, prop)

      ensureMutationTrackingIsEnabled(tree, nestedPath)
      ensureValueDosntExistInStateTreeElsewhere(value)

      if (shouldTrackMutations(tree, nestedPath)) {
        if (!(prop in target)) {
          tree.objectChanges.add(path)
        }

        tree.addMutation({
          method: 'set',
          path: nestedPath,
          args: [value],
        })
      }

      return Reflect.set(target, prop, value)
    },
    deleteProperty(target, prop) {
      const nestedPath = concat(path, prop)

      ensureMutationTrackingIsEnabled(tree, nestedPath)

      if (shouldTrackMutations(tree, nestedPath)) {
        if (prop in target) {
          tree.objectChanges.add(path)
        }

        tree.addMutation({
          method: 'unset',
          path: nestedPath,
          args: [],
        })
      }

      delete target[prop]

      return true
    },
  })
}

function getValue(value, tree) {
  if (!value) {
    return value
  }

  if (value[IS_PROXY]) {
    return value[VALUE][tree.PROXY] || value[VALUE]
  }

  return value
}

export function proxify(tree, value, path?) {
  value = getValue(value, tree)
  if (value) {
    if (value[IS_PROXY] && value[PATH] !== path) {
      delete value[VALUE][tree.PROXY]
      Object.defineProperty(value[VALUE], tree.PROXY, {
        configurable: true,
        value: proxify(tree, value[VALUE], path),
      })
      return value[VALUE][tree.PROXY]
    } else if (value[IS_PROXY]) {
      return value
    } else if (isPlainObject(value)) {
      Object.defineProperty(value, tree.PROXY, {
        configurable: true,
        value: createObjectProxy(tree, value, path),
      })
      return value[tree.PROXY]
    } else if (Array.isArray(value)) {
      Object.defineProperty(value, tree.PROXY, {
        configurable: true,
        value: createArrayProxy(tree, value, path),
      })
      return value[tree.PROXY]
    }
  }
  return value
}
