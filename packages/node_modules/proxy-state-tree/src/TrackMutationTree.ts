import { IProxyStateTree, VALUE } from './'
import { Proxifier } from './Proxyfier'

export interface IMutation {
  method: string
  path: string
  args: any[]
}

export interface IMutationCallback {
  (mutation: IMutation, paths: Set<string>, flushId: number): void
}

export interface ITrackMutationTree<T extends object> {
  addMutation(mutation: IMutation, objectChangePath?: string): void
  onMutation(callback: IMutationCallback): void
  canTrack(): boolean
  canMutate(): boolean
  dispose(): ITrackMutationTree<T>
  track(): ITrackMutationTree<T>
  master: IProxyStateTree<T>
  proxifier: Proxifier
  state: T
  mutations: IMutation[]
}

export class TrackMutationTree<T extends object>
  implements ITrackMutationTree<T> {
  private mutationCallbacks: IMutationCallback[] = []
  master: IProxyStateTree<T>
  state: T
  mutations: IMutation[] = []
  proxifier: Proxifier
  isTracking: boolean = false
  constructor(master: IProxyStateTree<T>) {
    this.master = master
    this.proxifier = new Proxifier(this)
    this.mutations = []
    this.state = this.proxifier.proxify(master.state[VALUE], '')
  }
  addMutation(mutation: IMutation, objectChangePath: string) {
    this.mutations.push(mutation)
    this.master.addMutation(mutation, objectChangePath)

    for (let callback of this.mutationCallbacks) {
      callback(
        mutation,
        new Set(
          objectChangePath ? [mutation.path, objectChangePath] : [mutation.path]
        ),
        this.master.currentFlushId
      )
    }
  }
  track() {
    this.isTracking = true
    this.master.currentTree = this
    return this
  }
  onMutation(callback: IMutationCallback) {
    this.mutationCallbacks.push(callback)
  }
  canMutate() {
    return this.isTracking
  }
  canTrack() {
    return false
  }
  dispose() {
    this.isTracking = false
    this.mutations.length = 0
    this.mutationCallbacks.length = 0
    return this
  }
}
