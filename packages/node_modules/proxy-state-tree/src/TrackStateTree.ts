import { IProxyStateTree, VALUE, IMutation } from './'
import { Proxifier } from './Proxyfier'

export interface ITrackCallback {
  (
    mutations: IMutation[],
    paths: Set<string>,
    flushId: number,
    isAsync: boolean
  ): void
}

export interface ITrackScopedCallback<T extends object> {
  (tree: TrackStateTree<T>): any
}

export interface ITrackStateTree<T extends object> {
  addTrackingPath(path: string): void
  track(cb?: ITrackCallback)
  trackScope(scope: ITrackScopedCallback<T>, callback?: ITrackCallback): any
  canTrack(): boolean
  canMutate(): boolean
  dispose(): ITrackStateTree<T>
  master: IProxyStateTree<T>
  proxifier: Proxifier
  state: T
  pathDependencies: Set<string>
}

export class TrackStateTree<T extends object> implements ITrackStateTree<T> {
  master: IProxyStateTree<T>
  pathDependencies: Set<string> = new Set()
  isTracking: boolean = false
  callback: ITrackCallback | null
  state: T
  proxifier: Proxifier
  constructor(master: IProxyStateTree<T>) {
    this.master = master
    this.proxifier = new Proxifier(this)
    this.state = this.proxifier.proxify(master.state[VALUE], '')
  }
  canMutate() {
    return false
  }
  canTrack() {
    return this.isTracking
  }
  addTrackingPath(path: string) {
    this.pathDependencies.add(path)

    if (!this.callback) {
      return
    }

    this.master.addPathDependency(path, this.callback)
  }
  track(cb?: ITrackCallback) {
    this.isTracking = true
    this.master.currentTree = this
    this.pathDependencies.clear()

    if (cb) {
      this.callback = (mutations, paths, flushId, isAsync) => {
        for (let path of this.pathDependencies) {
          this.master.removePathDependency(path, this.callback)
        }
        this.pathDependencies.clear()
        cb(mutations, paths, flushId, isAsync)
      }
    }

    return this
  }
  trackScope(scope: ITrackScopedCallback<T>, cb?: ITrackCallback) {
    const previousTree = this.master.currentTree
    this.track(cb)
    const result = scope(this)
    this.isTracking = false
    this.master.currentTree = previousTree

    return result
  }
  dispose() {
    if (!this.callback) {
      this.pathDependencies.clear()

      return this
    }

    for (let path of this.pathDependencies) {
      this.master.removePathDependency(path, this.callback)
    }

    this.pathDependencies.clear()
    this.callback = null

    return this
  }
}
