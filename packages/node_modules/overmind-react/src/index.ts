import * as React from 'react'
import App, {
  Configuration,
  TConfig,
  EventType,
  ActionCallback,
} from 'overmind'

export * from 'overmind'

export type IReactComponent<P = any> =
  | React.StatelessComponent<P>
  | React.ComponentClass<P>
  | React.ClassicComponentClass<P>

export type TConnect<App extends { state: any; actions: any }> = {
  app: {
    state: App['state']
    actions: App['actions']
    reaction: (
      name: string,
      stateCb: (state: App['state']) => any,
      Function
    ) => void
  }
}

// Diff / Omit taken from https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-311923766
type Omit<T, K extends keyof T> = Pick<
  T,
  ({ [P in keyof T]: P } &
    { [P in K]: never } & { [x: string]: never; [x: number]: never })[keyof T]
>

let nextComponentId = 0

export default class ReactApp<
  Config extends Configuration,
  EvalConfig extends TConfig<Config>
> extends App<Config, EvalConfig> {
  connect = <
    Props,
    ConnectedActions = {
      [T in keyof EvalConfig['actions']]: EvalConfig['actions'][T] extends ActionCallback<
        EvalConfig
      >
        ? ReturnType<EvalConfig['actions'][T]>
        : {
            [P in keyof EvalConfig['actions'][T]]: EvalConfig['actions'][T][P] extends ActionCallback<
              EvalConfig
            >
              ? ReturnType<EvalConfig['actions'][T][P]>
              : undefined
          }
    }
  >(
    Component: IReactComponent<
      Props &
        TConnect<{
          state: EvalConfig['state']
          actions: ConnectedActions
        }>
    >
  ): IReactComponent<
    Omit<
      Props &
        TConnect<{
          state: EvalConfig['state']
          actions: ConnectedActions
        }>,
      keyof TConnect<{
        state: EvalConfig['state']
        actions: ConnectedActions
      }>
    >
  > => {
    let componentInstanceId = 0
    const instance = this
    const isClassComponent =
      Component.prototype && typeof Component.prototype.render === 'function'

    if (isClassComponent) {
      const originalRender = Component.prototype.render
      const originalWillUnmount = Component.prototype.componentWillUnmount

      Component.prototype.componentWillUnmount = function() {
        this.__isUnmounting = true
        if (this.__mutationListener) {
          instance.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
            componentId: this.__componentId,
            componentInstanceId: this.props.app.__componentInstanceId,
            name: Component.name || '',
          })

          this.__mutationListener.dispose()
        }
        originalWillUnmount && originalWillUnmount.call(this)
      }
      Component.prototype.render = function() {
        if (typeof this.__componentId === 'undefined') {
          this.__componentId = nextComponentId++
        }
        const trackId = instance.trackState()
        const value = originalRender.call(this)
        const paths = instance.clearTrackState(trackId)

        if (this.__mutationListener) {
          this.__mutationListener.update(paths)
        } else {
          instance.eventHub.emitAsync(EventType.COMPONENT_ADD, {
            componentId: this.__componentId,
            componentInstanceId: this.props.app.__componentInstanceId,
            name: Component.name || '',
            paths: Array.from(paths),
          })
          this.__mutationListener = instance.addMutationListener(
            paths,
            (flushId) => {
              if (this.__isUnmounting) {
                return
              }
              instance.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
                componentId: this.__componentId,
                componentInstanceId: this.props.app.__componentInstanceId,
                name: Component.name || '',
                paths: Array.from(paths),
                flushId,
              })
              this.forceUpdate()
            }
          )
        }

        return value
      }
    }

    return class extends React.PureComponent<
      Omit<
        Props &
          TConnect<{
            state: EvalConfig['state']
            actions: ConnectedActions
          }>,
        keyof TConnect<{
          state: EvalConfig['state']
          actions: ConnectedActions
        }>
      >
    > {
      __mutationListener: any
      __isUnmounting: boolean
      __componentId: number
      __componentInstanceId = componentInstanceId++
      __reactionFactory = instance.createReactionFactory(
        Component.name || Component.displayName
      )
      componentWillUnmount() {
        this.__isUnmounting = true
        if (this.__mutationListener) {
          instance.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
            componentId: this.__componentId,
            componentInstanceId: this.__componentInstanceId,
            name: Component.name || '',
          })
          this.__mutationListener.dispose()
        }
        this.__reactionFactory.dispose()
      }
      renderStatelessComponent() {
        const trackId = instance.trackState()
        const value = (Component as any)(
          Object.assign({}, this.props, {
            app: {
              state: instance.state,
              actions: instance.actions,
              reaction: this.__reactionFactory.add,
              __componentInstanceId: this.__componentInstanceId,
            },
          }),
          this.context
        )
        const paths = instance.clearTrackState(trackId)

        if (this.__mutationListener) {
          this.__mutationListener.update(paths)
        } else {
          instance.eventHub.emitAsync(EventType.COMPONENT_ADD, {
            componentId: this.__componentId,
            componentInstanceId: this.__componentInstanceId,
            name: Component.name || '',
            paths: Array.from(paths),
          })
          this.__mutationListener = instance.addMutationListener(
            paths,
            (flushId) => {
              if (this.__isUnmounting) {
                return
              }
              instance.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
                componentId: this.__componentId,
                componentInstanceId: this.__componentInstanceId,
                name: Component.name || '',
                paths: Array.from(paths),
                flushId,
              })
              this.forceUpdate()
            }
          )
        }

        return value
      }
      renderClassComponent() {
        return React.createElement(Component, Object.assign({}, this.props, {
          app: {
            state: instance.state,
            actions: instance.actions,
            reaction: this.__reactionFactory.add,
            __componentInstanceId: this.__componentInstanceId,
          },
        }) as any)
      }
      render() {
        if (isClassComponent) {
          return this.renderClassComponent()
        }

        if (typeof this.__componentId === 'undefined') {
          this.__componentId = nextComponentId++
        }

        return this.renderStatelessComponent()
      }
    }
  }
}
