import { TApp, Configuration, EventType, Overmind } from 'overmind'
import {
  // @ts-ignore
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  ClassicComponentClass,
  ComponentClass,
  createElement,
  PureComponent,
  StatelessComponent,
  // @ts-ignore
  useEffect,
  // @ts-ignore
  useState,
} from 'react'

export type IReactComponent<P = any> =
  | StatelessComponent<P>
  | ComponentClass<P>
  | ClassicComponentClass<P>

// Diff / Omit taken from https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-311923766
type Omit<T, K extends keyof T> = Pick<
  T,
  ({ [P in keyof T]: P } &
    { [P in K]: never } & { [x: string]: never; [x: number]: never })[keyof T]
>

export type TConnect<Config extends Configuration> = {
  app: {
    state: TApp<Config>['state']
    actions: TApp<Config>['actions']
    reaction: (
      name: string,
      stateCb: (state: TApp<Config>['state']) => any,
      Function
    ) => void
  }
}

let nextComponentId = 0

export const createHook = <App extends Overmind<Configuration>>(app: App) => {
  let componentInstanceId = 0
  const {
    ReactCurrentOwner,
  } = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  const useCurrentComponent = () => {
    return ReactCurrentOwner.current.elementType
  }

  return () => {
    const component = useCurrentComponent()
    const name = component.name
    component.__componentId =
      typeof component.__componentId === 'undefined'
        ? nextComponentId++
        : component.__componentId
    const [overmindState, setOvermindState] = useState(null)
    const trackId = app.trackState()
    useEffect(() => {
      const paths = app.clearTrackState(trackId)
      if (overmindState) {
        app.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
          componentId: component.__componentId,
          componentInstanceId: overmindState.componentInstanceId,
          name,
          paths: Array.from(paths),
        })
        overmindState.listener.update(paths)
      } else {
        const thisComponentInstanceId = componentInstanceId++
        setOvermindState({
          componentInstanceId: thisComponentInstanceId,
          listener: app.addMutationListener(paths, (flushId) => {
            app.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
              componentId: component.__componentId,
              componentInstanceId: thisComponentInstanceId,
              name,
              flushId,
              paths: Array.from(paths),
            })
            setOvermindState((state) => state)
          }),
        })
        app.eventHub.emitAsync(EventType.COMPONENT_ADD, {
          componentId: component.__componentId,
          componentInstanceId: thisComponentInstanceId,
          name,
          paths: Array.from(paths),
        })
      }
    })
    useEffect(
      () => {
        return () => {
          app.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
            componentId: component.__componentId,
            componentInstanceId: overmindState.componentInstanceId,
            name,
          })
          overmindState.listener.dispose()
        }
      },
      [component.__componentId]
    )
    return app
  }
}

export const createConnect = <App extends Overmind<Configuration>>(
  app: App
) => {
  return <Props>(
    Component: IReactComponent<Props & TConnect<App>>
  ): IReactComponent<Omit<Props & TConnect<App>, keyof TConnect<App>>> => {
    let componentInstanceId = 0
    const isClassComponent =
      Component.prototype && typeof Component.prototype.render === 'function'

    if (isClassComponent) {
      const originalRender = Component.prototype.render
      const originalWillUnmount = Component.prototype.componentWillUnmount

      Component.prototype.componentWillUnmount = function() {
        if (!this.props.app) {
          return originalWillUnmount && originalWillUnmount.call(this)
        }

        this.__isUnmounting = true
        if (this.__mutationListener) {
          app.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
            componentId: this.__componentId,
            componentInstanceId: this.props.app.__componentInstanceId,
            name: Component.name || '',
          })

          this.__mutationListener.dispose()
        }
        originalWillUnmount && originalWillUnmount.call(this)
      }
      Component.prototype.render = function() {
        if (!this.props.app) {
          return originalRender.call(this)
        }

        if (typeof this.__componentId === 'undefined') {
          this.__componentId = nextComponentId++
        }
        const trackId = app.trackState()
        const value = originalRender.call(this)
        const paths = app.clearTrackState(trackId)

        if (this.__mutationListener) {
          this.__mutationListener.update(paths)
          app.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
            componentId: this.__componentId,
            componentInstanceId: this.props.app.__componentInstanceId,
            name: Component.name || '',
            paths: Array.from(paths),
          })
        } else {
          app.eventHub.emitAsync(EventType.COMPONENT_ADD, {
            componentId: this.__componentId,
            componentInstanceId: this.props.app.__componentInstanceId,
            name: Component.name || '',
            paths: Array.from(paths),
          })
          this.__mutationListener = app.addMutationListener(
            paths,
            (flushId) => {
              if (this.__isUnmounting) {
                return
              }
              app.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
                componentId: this.__componentId,
                componentInstanceId: this.props.app.__componentInstanceId,
                name: Component.name || '',
                paths: Array.from(paths),
                flushId,
              })
              this.forceUpdate()
            }
          )
        }

        return value
      }
    }

    const klass = class extends PureComponent<
      Omit<Props & TConnect<App>, keyof TConnect<App>>
    > {
      __mutationListener: any
      __isUnmounting: boolean
      __componentId: number
      __componentInstanceId = componentInstanceId++
      __reactionFactory = app.createReactionFactory(
        Component.name || Component.displayName || 'Component'
      )
      componentWillUnmount() {
        this.__isUnmounting = true
        if (this.__mutationListener) {
          app.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
            componentId: this.__componentId,
            componentInstanceId: this.__componentInstanceId,
            name: Component.name || '',
          })
          this.__mutationListener.dispose()
        }
        this.__reactionFactory.dispose()
      }
      renderStatelessComponent() {
        const trackId = app.trackState()
        const value = (Component as any)(
          Object.assign({}, this.props, {
            app: {
              state: app.state,
              actions: app.actions,
              reaction: this.__reactionFactory.add,
              __componentInstanceId: this.__componentInstanceId,
            },
          }),
          this.context
        )
        const paths = app.clearTrackState(trackId)

        if (this.__mutationListener) {
          this.__mutationListener.update(paths)
          app.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
            componentId: this.__componentId,
            componentInstanceId: this.__componentInstanceId,
            name: Component.name || '',
            paths: Array.from(paths),
          })
        } else {
          app.eventHub.emitAsync(EventType.COMPONENT_ADD, {
            componentId: this.__componentId,
            componentInstanceId: this.__componentInstanceId,
            name: Component.name || '',
            paths: Array.from(paths),
          })
          this.__mutationListener = app.addMutationListener(
            paths,
            (flushId) => {
              if (this.__isUnmounting) {
                return
              }
              app.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
                componentId: this.__componentId,
                componentInstanceId: this.__componentInstanceId,
                name: Component.name || '',
                paths: Array.from(paths),
                flushId,
              })
              this.forceUpdate()
            }
          )
        }

        return value
      }
      renderClassComponent() {
        return createElement(Component, Object.assign({}, this.props, {
          app: {
            state: app.state,
            actions: app.actions,
            reaction: this.__reactionFactory.add,
            __componentInstanceId: this.__componentInstanceId,
          },
        }) as any)
      }
      render() {
        if (isClassComponent) {
          return this.renderClassComponent()
        }

        if (typeof this.__componentId === 'undefined') {
          this.__componentId = nextComponentId++
        }

        return this.renderStatelessComponent()
      }
    }

    Object.defineProperties(klass, {
      name: { value: Component.displayName || Component.name || '' },
    })
    return klass
  }
}
