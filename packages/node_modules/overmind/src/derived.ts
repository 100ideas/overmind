import ProxyStateTree from 'proxy-state-tree'

class Derived {
  isDirty: boolean
  proxyStateTreeListener: any
  value: any
  cb: (state: object) => void
  paths: Set<string>
  constructor(cb) {
    this.isDirty = true
    this.proxyStateTreeListener = null
    this.value = null
    this.cb = cb
    return this.evaluate.bind(this)
  }
  evaluate(proxyStateTree: ProxyStateTree) {
    if (this.isDirty) {
      const trackId = proxyStateTree.startPathsTracking()
      this.value = this.cb(proxyStateTree.get())
      this.isDirty = false
      this.paths = proxyStateTree.clearPathsTracking(trackId)
      if (this.proxyStateTreeListener) {
        this.proxyStateTreeListener.update(this.paths)
      } else {
        this.proxyStateTreeListener = proxyStateTree.addMutationListener(
          this.paths,
          () => {
            this.isDirty = true
          }
        )
      }
    }

    // Tracks the paths for the consumer of this derived value
    for (let path of this.paths) {
      proxyStateTree.addTrackingPath(path)
    }

    return this.value
  }
}

export default function derived<NewValue>(
  cb: (state: object) => NewValue
): NewValue {
  return (new Derived(cb) as any) as NewValue
}
