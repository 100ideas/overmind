import { EventEmitter } from 'betsy'
import { ProxyStateTree, VALUE, IS_PROXY } from 'proxy-state-tree'

import { EventType, Events } from './internalTypes'

export class Derived {
  private isDirty: boolean = true
  private proxyStateTreeListener: any = null
  private value: any = null
  private paths: Set<string>
  private updateCount: number = 0
  constructor(private cb: (state: object, parent: object) => void) {
    return this.evaluate.bind(this)
  }
  evaluate(
    eventHub: EventEmitter<Events>,
    proxyStateTree: ProxyStateTree,
    path
  ) {
    if (
      this.isDirty ||
      (this.value &&
        this.value[IS_PROXY] &&
        this.value[VALUE][(proxyStateTree as any).PROXY] !== this.value)
    ) {
      const state = proxyStateTree.get()
      const pathAsArray = path.split('.')
      pathAsArray.pop()
      const parent = pathAsArray.reduce((curr, key) => curr[key], state)
      const trackId = proxyStateTree.startPathsTracking()
      this.value = this.cb(state, parent)
      this.isDirty = false
      this.paths = proxyStateTree.clearPathsTracking(trackId)
      if (!this.proxyStateTreeListener) {
        this.proxyStateTreeListener = proxyStateTree.addMutationListener(
          (_, paths, flushId) => {
            if (this.isDirty) {
              return
            }

            for (let path of paths) {
              if (this.paths.has(path)) {
                eventHub.emitAsync(EventType.DERIVED_DIRTY, {
                  path,
                  flushId,
                })
                this.isDirty = true
                return
              }
            }
          }
        )
      }
      eventHub.emitAsync(EventType.DERIVED, {
        path,
        paths: Array.from(this.paths),
        updateCount: this.updateCount,
        value: this.value,
      })
      this.updateCount++
    }

    // Tracks the paths for the consumer of this derived value
    for (let path of this.paths) {
      proxyStateTree.addTrackingPath(path)
    }

    return this.value
  }
}
