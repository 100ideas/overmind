import {
  pipe,
  map,
  forEach,
  filter,
  fork,
  when,
  Operator,
  wait,
  debounce,
  run,
  parallel,
} from './'

function createMockAction(pipe) {
  return (value) =>
    new Promise((resolve, reject) => {
      const context = {
        state: {},
        value,
        execution: {
          actionId: 0,
          executionId: 0,
          operatorId: 0,
          path: [],
          startMutationTracking: () => {},
          clearMutationTracking: () => {},
          emit: () => {},
        },
      }
      pipe(
        null,
        context,
        (err, { value }) => {
          if (err) reject(err)
          else resolve(value)
        }
      )
    }).catch(console.error)
}

describe('PIPE', () => {
  test('should create and run pipes', () => {
    expect.assertions(1)
    const test = pipe((_, value, next) => {
      next(null, value)
    })

    return createMockAction(test)('foo').then((value) => {
      expect(value).toBe('foo')
    })
  })
  describe('OPERATORS', () => {
    test('map', () => {
      expect.assertions(1)
      const test: Operator<string, string> = pipe(
        map(({ value }) => value.toUpperCase())
      )

      return createMockAction(test)('foo').then((value) => {
        expect(value).toBe('FOO')
      })
    })
    test('map (async)', () => {
      expect.assertions(1)
      const test: Operator<string, string> = pipe(
        map(({ value }) => Promise.resolve(value.toUpperCase()))
      )

      return createMockAction(test)('foo').then((value) => {
        expect(value).toBe('FOO')
      })
    })
    test('forEach', () => {
      expect.assertions(1)
      let runCount = 0
      const test: Operator<string[], string[]> = pipe(
        forEach((_, val, next) => {
          runCount++
          next(null, val)
        })
      )

      return createMockAction(test)(['foo']).then(() => {
        expect(runCount).toEqual(1)
      })
    })
    test('parallel', () => {
      expect.assertions(1)
      let runCount = 0
      const test: Operator<string, string> = pipe(
        parallel([
          (_, value, next) => {
            runCount++
            next(null, value)
          },
          (_, value, next) => {
            runCount++
            next(null, value)
          },
        ])
      )

      return createMockAction(test)('foo').then(() => {
        expect(runCount).toEqual(2)
      })
    })
    test('filter - truthy', () => {
      expect.assertions(1)
      const test: Operator<string, string> = pipe(
        filter(({ value }) => value === 'foo'),
        map(({ value }) => value.toUpperCase())
      )

      return createMockAction(test)('foo').then((value) => {
        expect(value).toBe('FOO')
      })
    })
    test('filter - falsy', () => {
      const test: Operator<string, string> = pipe(
        filter(({ value }) => value === 'bar'),
        map(({ value }) => value.toUpperCase())
      )

      return createMockAction(test)('foo').then((value) => {
        expect(value).toBe('foo')
      })
    })
    test('fork', () => {
      expect.assertions(1)
      const test: Operator<string, string> = pipe(
        fork(() => 'foo', {
          foo: map(({ value }) => value.toUpperCase()),
        })
      )

      return createMockAction(test)('foo').then((value) => {
        expect(value).toBe('foo')
      })
    })
    test('when', () => {
      expect.assertions(1)
      const test: Operator<string, string | number> = pipe(
        when(() => true, {
          true: map(({ value }) => value.toUpperCase()),
          false: map(({ value }) => Number(value)),
        })
      )

      return createMockAction(test)('foo').then((value) => {
        expect(value).toBe('FOO')
      })
    })
    test('wait', () => {
      expect.assertions(1)
      const runTime = Date.now()
      const test: Operator<string, string> = pipe(wait(500))
      return createMockAction(test)('foo').then(() => {
        expect(Date.now() - runTime).toBeGreaterThanOrEqual(500)
      })
    })
    test('debounce', () => {
      expect.assertions(1)
      const test: Operator<string, string> = pipe(
        debounce(100),
        map(({ value }) => value.toUpperCase())
      )
      const action = createMockAction(test)
      return Promise.all([action('foo'), action('foo')]).then((value) => {
        expect(value).toEqual(['foo', 'FOO'])
      })
    })
    test('run', () => {
      expect.assertions(1)
      const test: Operator<string, string> = pipe(
        run(({ value }) => value + '!!!')
      )
      const action = createMockAction(test)
      return action('foo').then((value) => {
        expect(value).toEqual('foo')
      })
    })
    test('run (async)', () => {
      expect.assertions(2)
      let hasRun = false
      const test: Operator<string, string> = pipe(
        run(({ value }) => Promise.resolve(value + '!!!')),
        run(() => (hasRun = true))
      )
      const action = createMockAction(test)
      const actionRun = action('foo')
      expect(hasRun).toBe(false)
      return actionRun.then((value) => {
        expect(value).toEqual('foo')
      })
    })
  })
})
