import { ActionChain } from 'action-chain'
import { EventEmitter } from 'betsy'
import ProxyStateTree from 'proxy-state-tree'
import Devtools, { Message, safeValue } from './Devtools'
import Action, { IValueAction, INoValueAction } from './Action'
import Reaction, { ReactionConfig } from './reaction'
export { default as namespaces, Namespace } from './namespaces'
export { default as derived } from './derived'
export { default as computed } from './computed'

type Configuration<State, Providers, Actions, Reactions> = {
  state?: State
  providers?: Providers
  actions?: Actions
  reactions?: Reactions
}

type Options = {
  devtools?: string
}

export interface Events {
  derived: {
    path: string
    paths: string[]
    updateCount: number
    value: any
  }
  computed: {
    path: string
    paths: string[]
    updateCount: number
    value: any
    limit: number
    cacheKeysCount: number
    cacheKeyIndex: number
  }
  'reaction:add': {
    path: string
    statePath: string
    updateCount: number
  }
  'reaction:update': {
    path: string
    statePath: string
    updateCount: number
  }
  'reaction:remove': {
    path: string
    statePath: string
    updateCount: number
  }
}

export type ActionsCallback<Providers, State> = (
  action: IAction<State, Providers & { state: State }>
) => any

export type ReactionsCallback<State, Providers> = (
  reaction: ReactionConfig<State, Providers>,
  action: IAction<State, Providers & { state: State }>
) => any

export type TContext<State, Providers = {}> = Providers & {
  state: State
}

export interface IAction<State, Context> {
  <InitialValue = void>(): [InitialValue] extends [void]
    ? INoValueAction<State, Context, InitialValue>
    : IValueAction<State, Context, InitialValue>
}

export default class App<
  State extends object,
  Providers extends object,
  Reactions extends
    | ReactionsCallback<State, Providers>
    | {
        [namespace: string]: ReactionsCallback<State, any>
      },
  Actions extends
    | ActionsCallback<Providers, State>
    | {
        [namespace: string]: ActionsCallback<{}, {}>
      }
> {
  private proxyStateTree: ProxyStateTree
  private eventHub: EventEmitter<Events>
  devtools: Devtools
  actions: Actions extends ActionsCallback<Providers, State>
    ? ReturnType<Actions>
    : Actions extends {
        [namespace: string]: ActionsCallback<{}, {}>
      }
      ? { [Namespace in keyof Actions]: ReturnType<Actions[Namespace]> }
      : any
  state: State
  constructor(
    configuration: Configuration<State, Providers, Actions, Reactions>,
    options: Options = {}
  ) {
    /*
      Set up an eventHub to trigger information from derived, computed and reactions
    */
    const eventHub = new EventEmitter<Events>()

    /*
      Create the proxy state tree instance with the state and a wrapper to expose
      the eventHub
    */
    const proxyStateTree = new ProxyStateTree(configuration.state || {}, {
      dynamicWrapper: (proxyStateTree, path, func) =>
        func(eventHub, proxyStateTree, path),
    })

    /*
      The action chain with the context configuration
    */
    const actionChain = new ActionChain(
      Object.assign(
        {
          state: proxyStateTree.get(),
        },
        configuration.providers || ({} as Providers)
      ),
      {
        providerExceptions: ['state'],
      }
    )

    /*
      The action factory function
    */
    const action = function<InitialValue>(): [InitialValue] extends [void]
      ? INoValueAction<State, Providers & { state: State }, InitialValue>
      : IValueAction<State, Providers & { state: State }, InitialValue> {
      return new Action(proxyStateTree, actionChain) as any
    }

    if (options.devtools && typeof window !== 'undefined') {
      this.initializeDevtools(
        options.devtools,
        actionChain,
        eventHub,
        proxyStateTree
      )
    }

    this.initializeReactions(configuration, eventHub, proxyStateTree, action)

    /*
      Identify when the state tree should flush out changes
    */
    actionChain.on('operator:async', () => {
      if (this.devtools) {
        this.devtools.send({
          type: 'flush',
          data: { mutations: proxyStateTree.mutations },
        })
      }
      proxyStateTree.flush()
    })
    actionChain.on('action:end', () => {
      if (this.devtools) {
        this.devtools.send({
          type: 'flush',
          data: { mutations: proxyStateTree.mutations },
        })
      }
      proxyStateTree.flush()
    })

    /*
      Expose the created actions
    */
    this.actions = this.getActions(configuration, action)

    this.state = proxyStateTree.get()
    this.proxyStateTree = proxyStateTree
    this.eventHub = eventHub
  }
  private initializeDevtools(host, actionChain, eventHub, proxyStateTree) {
    const devtools = new Devtools()
    devtools.connect(
      host,
      (message: Message) => {
        // To use for communication from devtools app
      }
    )
    devtools.send({
      type: 'init',
      data: {
        state: proxyStateTree.get(),
      },
    })
    actionChain.on('action:start', (data) =>
      devtools.send({
        type: 'action:start',
        data,
      })
    )
    actionChain.on('operator:start', (data) =>
      devtools.send({
        type: 'operator:start',
        data,
      })
    )
    actionChain.on('operator:end', (data) =>
      devtools.send({
        type: 'operator:end',
        data: {
          ...data,
          result: safeValue(data.result),
        },
      })
    )
    actionChain.on('action:end', (data) =>
      devtools.send({
        type: 'action:end',
        data,
      })
    )
    actionChain.on('provider', (data) =>
      devtools.send({
        type: 'provider',
        data,
      })
    )
    actionChain.on('mutations', (data) =>
      devtools.send({
        type: 'mutations',
        data,
      })
    )
    eventHub.on('derived', (data) =>
      devtools.send({
        type: 'derived',
        data,
      })
    )
    eventHub.on('computed', (data) =>
      devtools.send({
        type: 'computed',
        data,
      })
    )
    eventHub.on('reaction:add', (data) =>
      devtools.send({
        type: 'reaction:add',
        data,
      })
    )
    eventHub.on('reaction:update', (data) =>
      devtools.send({
        type: 'reaction:update',
        data,
      })
    )
    eventHub.on('reaction:remove', (data) =>
      devtools.send({
        type: 'reaction:remove',
        data,
      })
    )
    this.devtools = devtools
  }
  private initializeReactions(configuration, eventHub, proxyStateTree, action) {
    if (typeof configuration.reactions === 'function') {
      const reactions = (configuration.reactions as any)(
        (stateCb, action) => [stateCb, action],
        action
      )
      Object.keys(reactions).forEach((key) => {
        const reaction = new Reaction(eventHub, proxyStateTree, key)
        reaction.create(reactions[key][0], reactions[key][1])
      })
    } else {
      const reactions = Object.keys(configuration.reactions || {}).reduce(
        (aggr, namespace) =>
          Object.assign(
            aggr,
            configuration.reactions[namespace]
              ? {
                  [namespace]: (configuration.reactions[namespace] as any)(
                    (stateCb, action) => [stateCb, action],
                    action
                  ),
                }
              : {}
          ),
        {}
      )
      Object.keys(reactions).forEach((namespace) => {
        Object.keys(reactions[namespace]).forEach((key) => {
          const reaction = new Reaction(
            eventHub,
            proxyStateTree,
            namespace + '.' + key
          )
          reaction.create(
            reactions[namespace][key][0],
            reactions[namespace][key][1]
          )
        })
      })
    }
  }
  private getActions(configuration, action) {
    return typeof configuration.actions === 'function'
      ? (configuration.actions as ActionsCallback<Providers, State>)(
          action as IAction<State, Providers & { state: State }>
        )
      : (Object.keys(configuration.actions || {}).reduce(
          (aggr, namespace) =>
            Object.assign(
              aggr,
              configuration.actions[namespace]
                ? {
                    [namespace]: configuration.actions[namespace](
                      action as IAction<State, Providers & { state: State }>
                    ),
                  }
                : {}
            ),
          {}
        ) as any)
  }
  trackState() {
    return this.proxyStateTree.startPathsTracking()
  }
  clearTrackState(id: number) {
    return this.proxyStateTree.clearPathsTracking(id)
  }
  addMutationListener(paths, cb) {
    return this.proxyStateTree.addMutationListener(paths, cb)
  }
  createReactionFactory() {
    const reactions = []
    const instance = this
    return {
      add(name: string, stateCb: (state: State) => any, cb: Function) {
        const reaction = new Reaction(
          instance.eventHub,
          instance.proxyStateTree,
          'view.' + name
        )
        reaction.create(stateCb, cb)

        reactions.push(reaction)
      },
      dispose() {
        reactions.forEach((reaction) => reaction.destroy())
        reactions.length = 0
      },
    }
  }
}
