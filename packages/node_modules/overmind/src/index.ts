import { ActionChain } from 'action-chain'
import { EventEmitter } from 'betsy'
import ProxyStateTree from 'proxy-state-tree'
import Devtools, { Message, safeValue } from './Devtools'
import Action, { IValueAction, INoValueAction } from './Action'
import Reaction, { ReactionConfig } from './reaction'
import { Namespaced } from './namespaces'
export { default as namespaces, Namespace } from './namespaces'
export { default as derive } from './derived'
export { default as compute } from './computed'

export { IValueAction }

type Configuration<State, Effects, Actions, Reactions> = {
  state?: State
  effects?: Effects
  actions?: Actions
  reactions?: Reactions
}

type TConfig<Config> = Config extends Configuration<any, any, any, any>
  ? {
      state: Config['state']
      effects: Config['effects']
    }
  : Namespaced<Config>

export type TModule<Config extends Configuration<any, any, any, any>> = {
  state: Config['state']
  effects: Config['effects']
}

export type TModules<Config> = Namespaced<Config>

type Options = {
  devtools?: string
}

type CacheMessage = {
  value: any
  paths: string[]
  updateCount: number
}

export enum EventType {
  DERIVED = 'derived',
  DERIVED_DIRTY = 'derived:dirty',
  COMPUTED = 'computed',
  COMPUTED_DIRTY = 'computed:dirty',
  REACTION_ADD = 'reaction:add',
  REACTION_UPDATE = 'reaction:update',
  REACTION_REMOVE = 'reaction:remove',
  COMPONENT_ADD = 'component:add',
  COMPONENT_UPDATE = 'component:update',
  COMPONENT_REMOVE = 'component:remove',
}

export interface Events {
  [EventType.DERIVED]: {
    path: string
    paths: string[]
    updateCount: number
    value: any
  }
  [EventType.DERIVED_DIRTY]: {
    path: string
    flushId: number
  }
  [EventType.COMPUTED]: {
    path: string
    updateCount: number
    cache: CacheMessage[]
    limit: number
  }
  [EventType.COMPUTED_DIRTY]: {
    path: string
    flushId: number
  }
  [EventType.REACTION_ADD]: {
    path: string
    statePath: string
    updateCount: number
  }
  [EventType.REACTION_UPDATE]: {
    path: string
    statePath: string
    updateCount: number
  }
  [EventType.REACTION_REMOVE]: {
    path: string
    statePath: string
    updateCount: number
  }
  [EventType.COMPONENT_ADD]: {
    componentId: number
    componentInstanceId: number
    name: string
    paths: string[]
  }
  [EventType.COMPONENT_UPDATE]: {
    componentId: number
    componentInstanceId: number
    name: string
    paths: string[]
    flushId: number
  }
  [EventType.COMPONENT_REMOVE]: {
    componentId: number
    componentInstanceId: number
    name: string
  }
}

export type ActionCallback<State, Effects> = (
  action: TActionCreator<{ state: State; effects: Effects }>
) => any

export type ReactionCallback<State, Effects> = (
  reaction: ReactionConfig<State, Effects>,
  action: TActionCreator<{ state: State; effects: Effects }>
) => any

export type TAction<InitialValue, App> = (
  action: TActionCreator<App>
) => [InitialValue] extends [void]
  ? INoValueAction<
      TConfig<App>['state'],
      TConfig<App>['effects'] & { state: TConfig<App>['state'] },
      InitialValue,
      any
    >
  : IValueAction<
      TConfig<App>['state'],
      TConfig<App>['effects'] & { state: TConfig<App>['state'] },
      InitialValue,
      any
    >

export type TActionCreator<App> = {
  <InitialValue = void>(): TActionCaller<InitialValue, App>
}

export type TActionCaller<InitialValue, App> = [InitialValue] extends [void]
  ? INoValueAction<
      TConfig<App>['state'],
      TConfig<App>['effects'] & { state: TConfig<App>['state'] },
      InitialValue
    >
  : IValueAction<
      TConfig<App>['state'],
      TConfig<App>['effects'] & { state: TConfig<App>['state'] },
      InitialValue
    >

export namespace TOperation {
  export type Mutation<Value, App> = (
    state: TConfig<App>['state'],
    value: Value
  ) => void
  export type Map<Value, ReturnValue, App> = (
    effects: TConfig<App>['effects'] & { state: TConfig<App>['state'] },
    value: Value
  ) => ReturnValue
  export type Filter<Value, App> = (
    effects: TConfig<App>['effects'] & { state: TConfig<App>['state'] },
    value: Value
  ) => boolean
  export type When<Value, App> = (
    effects: TConfig<App>['effects'] & { state: TConfig<App>['state'] },
    value: Value
  ) => boolean
  export type Do<Value, App> = (
    effects: TConfig<App>['effects'] & { state: TConfig<App>['state'] },
    value: Value
  ) => void
  export type Fork<Value, App> = (
    effects: TConfig<App>['effects'] & { state: TConfig<App>['state'] },
    value: Value
  ) => string
  export type Try<Value, ReturnValue, App> = (
    effects: TConfig<App>['effects'] & { state: TConfig<App>['state'] },
    value: Value
  ) => ReturnValue
}

export type TReaction<App> = (
  reaction: (getState: (state: TConfig<App>['state']) => any) => any,
  action: TActionCreator<App>
) => any

export type TDerive<App> = (state: TConfig<App>['state']) => any

export type TCompute<Value, App> = (
  value: Value
) => (state: TConfig<App>['state']) => any

export default class App<
  State extends object,
  Effects extends object,
  Reactions extends
    | {
        [name: string]: ReactionCallback<State, Effects>
      }
    | {
        [namespace: string]: ReactionCallback<State, Effects>
      },
  Actions extends
    | {
        [name: string]: ActionCallback<State, Effects>
      }
    | {
        [namespace: string]: {
          [name: string]: ActionCallback<State, Effects>
        }
      }
> {
  private proxyStateTree: ProxyStateTree
  eventHub: EventEmitter<Events>
  devtools: Devtools
  actions: Actions extends {
    [namespace: string]: {
      [name: string]: ActionCallback<State, Effects>
    }
  }
    ? {
        [T in keyof Actions]: {
          [P in keyof Actions[T]]: ReturnType<Actions[T][P]>
        }
      }
    : Actions extends {
        [name: string]: ActionCallback<State, Effects>
      }
      ? { [P in keyof Actions]: ReturnType<Actions[P]> }
      : any
  state: State
  constructor(
    configuration: Configuration<State, Effects, Actions, Reactions>,
    options: Options = {}
  ) {
    /*
      Set up an eventHub to trigger information from derived, computed and reactions
    */
    const eventHub = new EventEmitter<Events>()

    /*
      Create the proxy state tree instance with the state and a wrapper to expose
      the eventHub
    */
    const proxyStateTree = new ProxyStateTree(configuration.state || {}, {
      dynamicWrapper: (proxyStateTree, path, func) =>
        func(eventHub, proxyStateTree, path),
    })

    /*
      The action chain with the context configuration
    */
    const actionChain = new ActionChain(
      Object.assign(
        {
          state: proxyStateTree.get(),
        },
        configuration.effects || ({} as Effects)
      ),
      {
        providerExceptions: ['state'],
      }
    )

    /*
      The action factory function
    */
    const action = function<InitialValue>(): [InitialValue] extends [void]
      ? INoValueAction<State, Effects & { state: State }, InitialValue>
      : IValueAction<State, Effects & { state: State }, InitialValue> {
      return new Action(proxyStateTree, actionChain) as any
    }

    if (options.devtools && typeof window !== 'undefined') {
      this.initializeDevtools(
        options.devtools,
        actionChain,
        eventHub,
        proxyStateTree
      )
    }

    this.initializeReactions(configuration, eventHub, proxyStateTree, action)

    /*
      Identify when the state tree should flush out changes

      TODO:
        - How should I know when an operator is connected to a flushId?
        - Pass in operatorId on :async and set flushId directly?
        - Store operatorId on the flush and check?
    */
    actionChain.on('operator:async', (data) => {
      const flushData = proxyStateTree.flush()
      if (this.devtools && flushData.mutations.length) {
        this.devtools.send({
          type: 'flush',
          data: {
            ...data,
            ...flushData,
          },
        })
      }
    })
    actionChain.on('action:end', (data) => {
      const flushData = proxyStateTree.flush()
      if (this.devtools && flushData.mutations.length) {
        this.devtools.send({
          type: 'flush',
          data: {
            ...data,
            ...flushData,
          },
        })
      }
    })

    /*
      Expose the created actions
    */
    this.actions = this.getActions(configuration, action)

    this.state = proxyStateTree.get()
    this.proxyStateTree = proxyStateTree
    this.eventHub = eventHub
  }
  private initializeDevtools(host, actionChain, eventHub, proxyStateTree) {
    const devtools = new Devtools()
    devtools.connect(
      host,
      (message: Message) => {
        // To use for communication from devtools app
      }
    )
    actionChain.on('action:start', (data) =>
      devtools.send({
        type: 'action:start',
        data: {
          ...data,
          value: safeValue(data.value),
        },
      })
    )
    actionChain.on('operator:start', (data) =>
      devtools.send({
        type: 'operator:start',
        data,
      })
    )
    actionChain.on('operator:end', (data) =>
      devtools.send({
        type: 'operator:end',
        data: {
          ...data,
          result: safeValue(data.result),
        },
      })
    )
    actionChain.on('action:end', (data) =>
      devtools.send({
        type: 'action:end',
        data,
      })
    )
    actionChain.on('effect', (data) =>
      devtools.send({
        type: 'effect',
        data,
      })
    )
    actionChain.on('mutations', (data) =>
      devtools.send({
        type: 'mutations',
        data,
      })
    )
    for (let type in EventType) {
      eventHub.on(EventType[type], (data) =>
        devtools.send({
          type: EventType[type],
          data,
        })
      )
    }
    // This message is always the first as it is passed synchronously, all other
    // events are emitted async
    devtools.send({
      type: 'init',
      data: {
        state: proxyStateTree.get(),
      },
    })
    this.devtools = devtools
  }
  private initializeReactions(configuration, eventHub, proxyStateTree, action) {
    const reactions = Object.keys(configuration.reactions || {}).reduce(
      (aggr, name) => {
        if (typeof configuration.reactions[name] === 'function') {
          return Object.assign(aggr, {
            [name]: configuration.reactions[name](
              (stateCb, action) => [stateCb, action],
              action
            ),
          })
        }

        return Object.keys(configuration.reactions[name] || {}).reduce(
          (aggr, subName) =>
            Object.assign(aggr, {
              [name + '.' + subName]: configuration.reactions[name](
                (stateCb, action) => [stateCb, action],
                action
              ),
            }),
          {}
        )
      },
      {}
    )
    Object.keys(reactions).forEach((name) => {
      const reaction = new Reaction(eventHub, proxyStateTree, name)
      reaction.create(reactions[name][0], reactions[name][1])
    })
  }
  private getActions(configuration, action) {
    const actions = Object.keys(configuration.actions || {}).reduce(
      (aggr, name) => {
        if (typeof configuration.actions[name] === 'function') {
          return Object.assign(aggr, {
            [name]: configuration.actions[name](action),
          })
        } else if (configuration.actions[name]) {
          return Object.assign(aggr, {
            [name]: Object.keys(configuration.actions[name] || {}).reduce(
              (aggr, subName) =>
                Object.assign(aggr, {
                  [subName]: configuration.actions[name][subName](action),
                }),
              {}
            ),
          })
        }

        return aggr
      },
      {}
    ) as any

    if (this.devtools) {
      Object.keys(actions).forEach((key) => {
        if (typeof configuration.actions[key] === 'function') {
          actions[key].displayName = key
        } else {
          Object.keys(actions[key]).forEach((subKey) => {
            actions[key][subKey].displayName = key + '.' + subKey
          })
        }
      })
    }

    return actions
  }
  trackState() {
    return this.proxyStateTree.startPathsTracking()
  }
  clearTrackState(id: number) {
    return this.proxyStateTree.clearPathsTracking(id)
  }
  addMutationListener(paths, cb) {
    return this.proxyStateTree.addMutationListener(paths, cb)
  }
  createReactionFactory(prefix: string) {
    const reactions = []
    const instance = this
    return {
      add(name: string, stateCb: (state: State) => any, cb: Function) {
        const reaction = new Reaction(
          instance.eventHub,
          instance.proxyStateTree,
          prefix + '.' + name
        )
        reaction.create(stateCb, cb)

        reactions.push(reaction)
      },
      dispose() {
        reactions.forEach((reaction) => reaction.destroy())
        reactions.length = 0
      },
    }
  }
}
