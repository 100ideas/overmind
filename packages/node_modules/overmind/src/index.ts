import { EventEmitter } from 'betsy'
import { ProxyStateTree } from 'proxy-state-tree'
import { Derived } from './derived'
import { Devtools, Message, safeValue } from './Devtools'
import {
  EventType,
  Events,
  Options,
  ResolveActions,
  ResolveState,
} from './internalTypes'
import { Reaction } from './reaction'
import {
  BaseApp,
  Configuration,
  TDerive,
  TReaction,
  TAction,
  TContext,
  TOperator,
} from './types'
import { proxifyEffects } from './proxyfyEffects'

export * from './types'

/** This type can be overwriten by app developers if they want to avoid
 * typing and then they can import `Action`,  `Operation` etc. directly from
 * overmind.
 */
export interface IApp {}

type App = BaseApp & IApp

export type Action<Value = void, ReturnValue = any> = TAction<
  App,
  Value,
  ReturnValue
>

export type Context<Value> = TContext<App, Value>

export type Derive<Value> = TDerive<App, Value>

export type Reaction = TReaction<App>

export type OnInitialize = (context: Context<App['actions']>) => void

const isPlainObject = require('is-plain-object')
const IS_PRODUCTION = process.env.NODE_ENV === 'production'
const IS_DEVELOPMENT = process.env.NODE_ENV === 'development'
const IS_PIPE = Symbol('pipe')

export const log = (...objects: any[]) =>
  console.log(...objects.map((obj) => JSON.parse(JSON.stringify(obj))))

const hotReloadingCache = {}

// We do not use TApp<Config> directly to type the class in order to avoid
// the 'import(...)' function to be used in exported types.

export class Overmind<Config extends Configuration> implements BaseApp {
  private proxyStateTree: ProxyStateTree
  private actionReferences: Function[] = []
  private nextExecutionId: number = 0
  initialized: Promise<any>
  eventHub: EventEmitter<Events>
  devtools: Devtools
  actions: ResolveActions<Config['actions']>
  state: ResolveState<Config['state']>
  effects: Config['effects']
  constructor(configuration: Config, options: Options = {}) {
    const name = options.name || 'MyApp'

    if (IS_DEVELOPMENT) {
      if (hotReloadingCache[name]) {
        return hotReloadingCache[name]
      } else {
        hotReloadingCache[name] = this
      }
    }

    /*
      Set up an eventHub to trigger information from derived, computed and reactions
    */
    const eventHub = new EventEmitter<Events>()

    /*
      Create the proxy state tree instance with the state and a wrapper to expose
      the eventHub
    */
    const proxyStateTree = new ProxyStateTree(this.getState(configuration), {
      dynamicWrapper: (proxyStateTree, path, func) =>
        func(eventHub, proxyStateTree, path),
    })

    this.state = proxyStateTree.get()
    this.effects = configuration.effects || {}
    this.proxyStateTree = proxyStateTree
    this.eventHub = eventHub

    /*
      The action factory function
    */

    if (options.devtools !== false && typeof window !== 'undefined') {
      this.initializeDevtools(options.devtools, eventHub, proxyStateTree)
    }

    this.initializeReactions(configuration, eventHub, proxyStateTree)

    /*
      Identify when the state tree should flush out changes

      TODO:
        - How should I know when an operator is connected to a flushId?
        - Pass in operatorId on :async and set flushId directly?
        - Store operatorId on the flush and check?
    */
    eventHub.on(EventType.OPERATOR_ASYNC, (data) => {
      const flushData = proxyStateTree.flush()
      if (this.devtools && flushData.mutations.length) {
        this.devtools.send({
          type: 'flush',
          data: {
            ...data,
            ...flushData,
          },
        })
      }
    })
    eventHub.on(EventType.ACTION_END, (data) => {
      const flushData = proxyStateTree.flush()
      if (this.devtools && flushData.mutations.length) {
        this.devtools.send({
          type: 'flush',
          data: {
            ...data,
            ...flushData,
          },
        })
      }
    })

    /*
      Expose the created actions
    */
    this.actions = this.getActions(configuration)

    if (configuration.onInitialize) {
      const onInitialize = this.createAction(
        'onInitialize',
        configuration.onInitialize
      )

      this.initialized = Promise.resolve(onInitialize(this.actions))
    } else {
      this.initialized = Promise.resolve(null)
    }
  }
  private createExecution(name, action) {
    return {
      actionId: this.actionReferences.indexOf(action),
      executionId: this.nextExecutionId++,
      actionName: name,
      operatorId: 0,
      path: [],
      startMutationTracking: this.proxyStateTree.startMutationTracking.bind(
        this.proxyStateTree
      ),
      clearMutationTracking: this.proxyStateTree.clearMutationTracking.bind(
        this.proxyStateTree
      ),
      emit: this.eventHub.emit.bind(this.eventHub),
    }
  }
  private createContext(value, execution, state) {
    return Object.assign(
      {
        value,
        state,
        execution,
      },
      this.trackEffects(this.effects, execution)
    )
  }
  private createAction(name, action) {
    this.actionReferences.push(action)
    return (value?) => {
      if (IS_PRODUCTION) {
        return action(value)
      } else if (action[IS_PIPE]) {
        return new Promise((resolve, reject) => {
          const execution = this.createExecution(name, action)
          this.eventHub.emit(EventType.ACTION_START, execution)

          action(
            null,
            this.createContext(value, execution, this.proxyStateTree.get()),
            (err, val) => {
              this.eventHub.emit(EventType.ACTION_END, execution)
              if (err) reject(err)
              else resolve(val)
            }
          )
        })
      } else {
        const execution = this.createExecution(name, action)
        this.eventHub.emit(EventType.ACTION_START, execution)
        this.eventHub.emit(EventType.OPERATOR_START, {
          ...execution,
          operatorId: 0,
          name: undefined,
          type: 'action',
        })
        const scopedTree = this.proxyStateTree.getScopedTree()
        scopedTree.startMutationTracking()
        const result = action(
          this.createContext(value, execution, scopedTree.get())
        )
        this.eventHub.emit(EventType.OPERATOR_END, {
          ...execution,
          isAsync: result instanceof Promise,
          name: undefined,
          operatorId: 0,
          type: 'action',
          value: undefined,
        })
        this.eventHub.emit(EventType.ACTION_END, execution)
        const mutations = scopedTree.clearMutationTracking()
        mutations.length &&
          this.eventHub.emit(EventType.MUTATIONS, {
            ...execution,
            operatorId: 0,
            mutations,
          })
        scopedTree.startMutationTracking()
        scopedTree.addMutationListener((mutation) => {
          this.eventHub.emit(EventType.MUTATIONS, {
            ...execution,
            operatorId: 0,
            mutations: [mutation],
          })
          setTimeout(() => {
            scopedTree.clearMutationTracking()
            const flushData = scopedTree.flush()
            if (flushData.mutations.length) {
              this.devtools.send({
                type: 'flush',
                data: {
                  ...execution,
                  ...flushData,
                },
              })
            }
            scopedTree.startMutationTracking()
          })
        })

        const flushData = scopedTree.flush()
        if (this.devtools && flushData.mutations.length) {
          this.devtools.send({
            type: 'flush',
            data: {
              ...execution,
              ...flushData,
            },
          })
        }
        return Promise.resolve(result)
      }
    }
  }
  private trackEffects(effects = {}, execution) {
    if (IS_PRODUCTION) {
      return effects
    }

    return proxifyEffects(this.effects, (effect) =>
      this.eventHub.emitAsync(EventType.EFFECT, { ...execution, ...effect })
    )
  }
  private initializeDevtools(host, eventHub, proxyStateTree) {
    const devtools = new Devtools(
      typeof document === 'undefined' ? 'NoName' : document.title || 'NoName'
    )
    devtools.connect(
      host,
      (message: Message) => {
        // To use for communication from devtools app
      }
    )
    for (let type in EventType) {
      eventHub.on(EventType[type], (data) =>
        devtools.send({
          type: EventType[type],
          data,
        })
      )
    }
    // This message is always the first as it is passed synchronously, all other
    // events are emitted async
    devtools.send({
      type: 'init',
      data: {
        state: proxyStateTree.get(),
      },
    })
    this.devtools = devtools
  }
  private initializeReactions(configuration, eventHub, proxyStateTree) {
    const reactions = Object.keys(configuration.reactions || {}).reduce(
      (aggr, name) => {
        if (typeof configuration.reactions[name] === 'function') {
          return Object.assign(aggr, {
            [name]: configuration.reactions[name]((stateCb, action) => {
              action.displayName = name
              return [stateCb, action]
            }, this.createAction.bind(this, name)),
          })
        }

        return Object.keys(configuration.reactions[name] || {}).reduce(
          (aggr, subName) =>
            Object.assign(aggr, {
              [name + '.' + subName]: configuration.reactions[name](
                (stateCb, action) => {
                  action.displayName = name + '.' + subName
                  return [stateCb, action]
                },
                this.createAction.bind(this, subName)
              ),
            }),
          {}
        )
      },
      {}
    )
    Object.keys(reactions).forEach((name) => {
      const reaction = new Reaction(eventHub, proxyStateTree, name)
      reaction.create(reactions[name][0], reactions[name][1])
    })
  }
  private getState(configuration: Configuration) {
    let state = {}
    if (configuration.state) {
      state = this.processState(configuration.state)
    }

    return state
  }
  private processState(state: {}) {
    return Object.keys(state).reduce((aggr, key) => {
      if (key === '__esModule') {
        return aggr
      }

      const value = state[key]
      if (isPlainObject(value)) {
        aggr[key] = this.processState(value)
      } else if (typeof value === 'function') {
        aggr[key] = new Derived(value)
      } else {
        aggr[key] = value
      }

      return aggr
    }, {})
  }
  private getActions(configuration: Configuration) {
    let actions = {}
    if (configuration.actions) {
      actions = configuration.actions
    }

    const evaluatedActions = Object.keys(actions).reduce((aggr, name) => {
      if (typeof actions[name] === 'function') {
        return Object.assign(aggr, {
          [name]: this.createAction(name, actions[name]),
        })
      }

      return Object.assign(aggr, {
        [name]: Object.keys(actions[name] || {}).reduce(
          (aggr, subName) =>
            Object.assign(
              aggr,
              typeof actions[name][subName] === 'function'
                ? {
                    [subName]: this.createAction(
                      subName,
                      actions[name][subName]
                    ),
                  }
                : {}
            ),
          {}
        ),
      })
    }, {}) as any

    if (this.devtools) {
      Object.keys(evaluatedActions).forEach((key) => {
        if (typeof evaluatedActions[key] === 'function') {
          evaluatedActions[key].displayName = key
        } else {
          Object.keys(evaluatedActions[key]).forEach((subKey) => {
            evaluatedActions[key][subKey].displayName = key + '.' + subKey
          })
        }
      })
    }

    return evaluatedActions
  }
  trackState() {
    return this.proxyStateTree.startPathsTracking()
  }
  clearTrackState(id: number, cb?: () => void) {
    return this.proxyStateTree.clearPathsTracking(id, cb)
  }
  addMutationListener(paths, cb) {
    return this.proxyStateTree.addFlushListener(paths, cb)
  }
  createReactionFactory(prefix: string) {
    const reactions = []
    const instance = this
    return {
      add(
        name: string,
        stateCb: (state: ResolveState<Config['state'] & {}>) => any,
        cb: Function
      ) {
        const reaction = new Reaction(
          instance.eventHub,
          instance.proxyStateTree,
          prefix + '.' + name
        )
        reaction.create(stateCb, cb)

        reactions.push(reaction)
      },
      dispose() {
        reactions.forEach((reaction) => reaction.destroy())
        reactions.length = 0
      },
    }
  }
}

/*
  PIPE
  needs to be in this file for typing override to work
*/

export type Pipe<Value, ReturnValue> = Operator<Value, ReturnValue>

export type Operator<C, RC> = TOperator<Context<C>, Context<RC>>

export function pipe<A, B>(aOperator: Operator<A, B>): Operator<A, B>

export function pipe<A, B, C>(
  aOperator: Operator<A, B>,
  bOperator: Operator<B, C>
): Operator<A, C>

export function pipe<A, B, C, D>(
  aOperator: Operator<A, B>,
  bOperator: Operator<B, C>,
  cOperator: Operator<C, D>
): Operator<A, D>

export function pipe<A, B, C, D, E>(
  aOperator: Operator<A, B>,
  bOperator: Operator<B, C>,
  cOperator: Operator<C, D>,
  dOperator: Operator<D, E>
): Operator<A, E>

export function pipe<A, B, C, D, E, F>(
  aOperator: Operator<A, B>,
  bOperator: Operator<B, C>,
  cOperator: Operator<C, D>,
  dOperator: Operator<D, E>,
  eOperator: Operator<E, F>
): Operator<A, F>

export function pipe<A, B, C, D, E, F, G>(
  aOperator: Operator<A, B>,
  bOperator: Operator<B, C>,
  cOperator: Operator<C, D>,
  dOperator: Operator<D, E>,
  eOperator: Operator<E, F>,
  fOperator: Operator<F, G>
): Operator<A, G>

export function pipe(...operators) {
  const instance = (err, context, next, final = next) => {
    if (err) next(err)
    else {
      let operatorIndex = 0
      const run = (runErr, runContext) =>
        operators[operatorIndex++](runErr, runContext, runNextOperator, final)

      const runNextOperator = (operatorError, operatorContext) => {
        if (operatorError) return next(operatorError)
        if (operatorIndex >= operators.length)
          return next(null, operatorContext)

        if (operatorContext.value instanceof Promise) {
          operatorContext.value
            .then((promiseValue) =>
              run(null, { ...operatorContext, value: promiseValue })
            )
            .catch((promiseError) => next(promiseError, operatorContext))
        } else {
          try {
            run(null, operatorContext)
          } catch (operatorError) {
            next(operatorError, operatorContext)
          }
        }
      }

      runNextOperator(null, context)
    }
  }
  instance[IS_PIPE] = true
  return instance
}

/*
  OPERATORS
*/

function startDebugOperator(type, operationName, execution) {
  if (IS_PRODUCTION) {
    return
  }

  const operatorId = execution.operatorId++
  execution.emit(EventType.OPERATOR_START, {
    ...execution,
    operatorId,
    name: operationName,
    type,
  })
  return (value?, isAsync = false) => {
    execution.emit(EventType.OPERATOR_END, {
      ...execution,
      operatorId,
      result: value && safeValue(value),
      isAsync,
      name: operationName,
      type,
    })
  }
}

export function map<Input, Output>(
  operation: (input: Context<Input>) => Output
): Operator<Input, Output extends Promise<infer U> ? U : Output> {
  return (err, context, next) => {
    if (err) next(err)
    else {
      const stopDebugOperator = startDebugOperator(
        'map',
        operation.name,
        context.execution
      )
      const value = operation(context)
      stopDebugOperator && stopDebugOperator(value)
      next(null, { ...context, value } as any)
    }
  }
}

export function run<Input>(
  operation: (input: Context<Input>) => void
): Operator<Input, Input> {
  return (err, context, next) => {
    if (err) next(err)
    else {
      const stopDebugOperator = startDebugOperator(
        'run',
        operation.name,
        context.execution
      )
      operation(context)
      stopDebugOperator && stopDebugOperator(context.value)
      next(null, context as any)
    }
  }
}

export function forEach<Input extends any[]>(
  forEachItemOperator: Operator<Input[0], any>
): Operator<Input, Input> {
  return (err, context, next) => {
    if (err) next(err)
    else {
      const stopDebugOperator = startDebugOperator(
        'forEach',
        '',
        context.execution
      )
      let array = context.value
      let evaluatingCount = array.length

      let hasErrored = false
      const evaluate = (err) => {
        if (hasErrored) {
          return
        }
        if (err) {
          hasErrored = true
          return next(err)
        }
        evaluatingCount--

        if (!evaluatingCount) {
          stopDebugOperator && stopDebugOperator()
          next(null, context)
        }
      }
      array.forEach((value) =>
        forEachItemOperator(null, { ...context, value }, evaluate)
      )
    }
  }
}

export function filter<Input>(
  operation: (input: Context<Input>) => boolean
): Operator<Input, Input> {
  return (err, context, next, final) => {
    if (err) next(err)
    else if (operation(context)) next(null, context)
    else final(null, context)
  }
}

export function mutate<Input>(
  operation: (input: Context<Input>) => void
): Operator<Input, Input> {
  return (err, context, next) => {
    if (err) next(err)
    else {
      const operatorId = context.execution.operatorId
      const stopDebugOperator = startDebugOperator(
        'mutate',
        operation.name,
        context.execution
      )
      context.execution.startMutationTracking()
      operation(context)
      const mutations = context.execution.clearMutationTracking()
      context.execution.emit(EventType.MUTATIONS, {
        ...context.execution,
        operatorId,
        mutations,
      })
      stopDebugOperator && stopDebugOperator()
      next(null, context)
    }
  }
}

export function fork<
  Input,
  Paths extends { [key: string]: Operator<Input, any> }
>(
  operation: (input: Context<Input>) => keyof Paths,
  paths: Paths
): Operator<Input, Input> {
  return (err, context, next) => {
    if (err) return next(err)
    paths[operation(context)](null, context, (err) => {
      if (err) next(err)
      else next(null, context)
    })
  }
}

export function when<Input, OutputA, OutputB>(
  operation: (input: Context<Input>) => boolean,
  paths: {
    true: Operator<Input, OutputA>
    false: Operator<Input, OutputB>
  }
): Operator<Input, OutputA | OutputB> {
  return (err, context, next) => {
    if (err) next(err)
    else if (operation(context)) paths.true(null, context, next)
    else paths.false(null, context, next)
  }
}

export function wait<Input>(ms: number): Operator<Input, Input> {
  return (err, context, next) => {
    if (err) next(err)
    else setTimeout(() => next(null, context), ms)
  }
}

export function debounce<Input>(ms: number): Operator<Input, Input> {
  let timeout
  let previousFinal
  return (err, value, next, final) => {
    if (err) {
      return next(err)
    }
    if (timeout) {
      clearTimeout(timeout)
      previousFinal(null, value)
    }
    previousFinal = final
    timeout = setTimeout(() => {
      timeout = null
      next(null, value)
    }, ms)
  }
}
