import { Action, Configuration } from './'

type SubType<Base, Condition> = Pick<
  Base,
  { [Key in keyof Base]: Base[Key] extends Condition ? Key : never }[keyof Base]
>

interface ConfigurationWithModules extends Configuration {
  modules?: {
    [namespace: string]: {
      onInitialize?: any
      state?: {}
      context?: {}
      actions?: {}
      reactions?: {}
    }
  }
}

type TState<Config extends ConfigurationWithModules> = [
  Config['state']
] extends [undefined]
  ? {
      [P in keyof SubType<Config['modules'], { state: {} }>]: SubType<
        Config['modules'],
        { state: {} }
      >[P]['state']
    }
  : [Config['modules']] extends [undefined]
    ? Config['state']
    : Config['state'] &
        {
          [P in keyof SubType<Config['modules'], { state: {} }>]: SubType<
            Config['modules'],
            { state: {} }
          >[P]['state']
        }

type TContext<Config extends ConfigurationWithModules> = [
  Config['context']
] extends [undefined]
  ? {
      [P in keyof SubType<Config['modules'], { context: object }>]: SubType<
        Config['modules'],
        { context: object }
      >[P]['context']
    }
  : [Config['modules']] extends [undefined]
    ? Config['context']
    : Config['context'] &
        {
          [P in keyof SubType<Config['modules'], { context: object }>]: SubType<
            Config['modules'],
            { context: object }
          >[P]['context']
        }

type TActions<Config extends ConfigurationWithModules> = [
  Config['actions']
] extends [undefined]
  ? {
      [P in keyof SubType<Config['modules'], { actions: object }>]: SubType<
        Config['modules'],
        { actions: object }
      >[P]['actions']
    }
  : [Config['modules']] extends [undefined]
    ? Config['actions']
    : Config['actions'] &
        {
          [P in keyof SubType<Config['modules'], { actions: object }>]: SubType<
            Config['modules'],
            { actions: object }
          >[P]['actions']
        }

function parseModule(
  result: { actions: any; context: any; state: any; initializers: any[] },
  modName: string,
  mod: Configuration
) {
  const { actions, context, onInitialize, state }: Configuration = mod

  if (actions) {
    result.actions[modName] = actions
  }
  if (context) {
    result.context[modName] = context
  }
  if (state) {
    result.state[modName] = state
  }
  if (onInitialize) {
    result.initializers.push(onInitialize)
  }
}

export function modules<T extends ConfigurationWithModules>(
  configWithModules: T
): {
  onInitialize?: any
  state: TState<T>
  context: TContext<T>
  actions: TActions<T>
} {
  const result: any = {
    initializers: [],
    actions: configWithModules.actions || {},
    context: configWithModules.context || {},
    state: configWithModules.state || {},
  }
  const modules = configWithModules.modules || {}

  if (configWithModules.onInitialize) {
    result.initilizers.push(configWithModules.onInitialize)
  }

  Object.keys(modules).forEach((modName) => {
    parseModule(result, modName, modules[modName])
  })

  const onInitialize = (action) => action.parallel(result.initializers)

  return {
    onInitialize,
    actions: result.actions,
    context: result.context,
    state: result.state,
  }
}
