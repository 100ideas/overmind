import {
  actionBaseFactory,
  ActionBase,
  NoValueActionBase,
  StopExecution,
  ExecutionContext,
  ActionChain,
} from 'action-chain'

type OperatorCallback<Context, Value, NewValue = Value> = (
  value: Value,
  context: Context
) => NewValue | Promise<NewValue>

interface Operators<State, Context, InitialValue, Value> {
  mutation(
    cb: (value: Value, state: State) => any
  ): InitialValue extends void
    ? NoValueAction<State, Context, InitialValue, Value>
    : Action<State, Context, InitialValue, Value>
  do(
    cb: (value: Value, context: Context) => void
  ): InitialValue extends void
    ? NoValueAction<State, Context, InitialValue, Value>
    : Action<State, Context, InitialValue, Value>
  map<NewValue>(
    cb: (value: Value, context: Context) => NewValue | Promise<NewValue>
  ): InitialValue extends void
    ? NoValueAction<State, Context, InitialValue, NewValue>
    : Action<State, Context, InitialValue, NewValue>
  try<ResolveValue, RejectValue, NewValue>(
    cb: OperatorCallback<Context, Value, NewValue>,
    paths: {
      success: Action<
        State,
        Context,
        ReturnType<OperatorCallback<Context, Value, NewValue>>,
        ResolveValue
      >
      error: Action<
        State,
        Context,
        ReturnType<OperatorCallback<Context, Value, NewValue>>,
        RejectValue
      >
    }
  ): InitialValue extends void
    ? NoValueAction<State, Context, InitialValue, ResolveValue | RejectValue>
    : Action<State, Context, InitialValue, ResolveValue | RejectValue>
  when<TrueValue, FalseValue>(
    cb: (value: Value, context: Context) => boolean,
    paths: {
      true: Action<State, Context, Value, TrueValue>
      false: Action<State, Context, Value, FalseValue>
    }
  ): InitialValue extends void
    ? NoValueAction<State, Context, InitialValue, TrueValue | FalseValue>
    : Action<State, Context, InitialValue, TrueValue | FalseValue>
  filter(
    cb: (value: Value, context: Context) => boolean
  ): InitialValue extends void
    ? NoValueAction<State, Context, InitialValue, Value>
    : Action<State, Context, InitialValue, Value>
  debounce(
    timer: number
  ): InitialValue extends void
    ? NoValueAction<State, Context, InitialValue, Value>
    : Action<State, Context, InitialValue, Value>
}

export interface Action<State, Context, InitialValue, Value = InitialValue>
  extends Operators<State, Context, InitialValue, Value>,
    ActionBase<Context, InitialValue, Value> {}

export interface NoValueAction<
  State,
  Context,
  InitialValue,
  Value = InitialValue
>
  extends Operators<State, Context, InitialValue, Value>,
    NoValueActionBase<Context, InitialValue, Value> {}

export default function createActionFactory<State, Context>(proxyStateTree) {
  return function actionFactory<InitialValue, Value = InitialValue>(
    actionChain: ActionChain<Context>,
    initialActionId?: number,
    runOperators?: (
      value: any,
      executionContext: ExecutionContext
    ) => any | Promise<any>
  ): InitialValue extends void
    ? NoValueAction<State, Context, InitialValue, Value>
    : Action<State, Context, InitialValue, Value> {
    return Object.assign(
      actionBaseFactory<Context, InitialValue, Value>(
        actionChain,
        initialActionId,
        runOperators
      ) as any,
      {
        mutation(cb: (value: Value, state: State) => any) {
          const operator = (value, context) => {
            proxyStateTree.startMutationTracking()
            cb(value, context.state)
            const mutations = proxyStateTree.clearMutationTracking()
            actionChain.emit('mutations', {
              mutations,
              ...context.__execution,
            })
          }

          const [
            chain,
            initialActionId,
            runOperators,
          ] = this.createOperatorResult('mutation', cb.name, operator)

          return actionFactory<InitialValue>(
            chain,
            initialActionId,
            runOperators
          )
        },
        do(cb: (value: Value, context: Context) => void) {
          const operator = (value, context) => {
            cb(value, context)
            return value
          }

          const [
            chain,
            initialActionId,
            runOperators,
          ] = this.createOperatorResult('do', cb.name, operator)

          return actionFactory<InitialValue, Value>(
            chain,
            initialActionId,
            runOperators
          )
        },
        map<NewValue>(
          cb: (value: Value, context: Context) => NewValue | Promise<NewValue>
        ) {
          const [
            chain,
            initialActionId,
            runOperators,
          ] = this.createOperatorResult('map', cb.name, cb)

          return actionFactory<InitialValue, NewValue>(
            chain,
            initialActionId,
            runOperators
          )
        },
        try<ResolveValue, RejectValue, NewValue>(
          cb: OperatorCallback<Context, Value, NewValue>,
          paths: {
            success: Action<
              State,
              Context,
              ReturnType<OperatorCallback<Context, Value, NewValue>>,
              ResolveValue
            >
            error: Action<
              State,
              Context,
              ReturnType<OperatorCallback<Context, Value, NewValue>>,
              RejectValue
            >
          }
        ) {
          const operator = (value, context) => {
            return (cb(value, context) as any)
              .then((promiseValue) => {
                return (paths.success as any)(promiseValue, context, 'success')
              })
              .catch((error) => {
                return (paths.error as any)(error, context, 'error')
              })
          }
          const [
            chain,
            initialActionId,
            runOperators,
          ] = this.createOperatorResult('try', cb.name, operator)

          return actionFactory<Value, ResolveValue | RejectValue>(
            chain,
            initialActionId,
            runOperators
          )
        },
        when<TrueValue, FalseValue>(
          cb: (value: Value, context: Context) => boolean,
          paths: {
            true: Action<State, Context, Value, TrueValue>
            false: Action<State, Context, Value, FalseValue>
          }
        ) {
          const operator = (value, context) => {
            const isTrue = cb(value, context)
            const path = isTrue ? paths.true : (paths.false as any)

            return path(value, context, isTrue ? 'true' : 'false')
          }
          const [
            chain,
            initialActionId,
            runOperators,
          ] = this.createOperatorResult('when', cb.name, operator)

          return actionFactory<Value, TrueValue | FalseValue>(
            chain,
            initialActionId,
            runOperators
          )
        },
        filter(cb: (value: Value, context: Context) => boolean) {
          const operator = (value, context) => {
            const result = cb(value, context)

            if (result === true) {
              return value
            }

            return new StopExecution(value)
          }
          const [
            chain,
            initialActionId,
            runOperators,
          ] = this.createOperatorResult('filter', cb.name, operator)

          return actionFactory<InitialValue, Value>(
            chain,
            initialActionId,
            runOperators
          )
        },
        debounce(timer: number) {
          let currentTimeout = null

          const operator = (value) => {
            return new Promise((resolve) => {
              if (currentTimeout) {
                currentTimeout()
              }
              const timeoutId = setTimeout(() => {
                resolve(value)
                currentTimeout = null
              }, timer)
              currentTimeout = () => {
                clearTimeout(timeoutId)
                resolve(new StopExecution(value))
              }
            })
          }
          const [
            chain,
            initialActionId,
            runOperators,
          ] = this.createOperatorResult('debounce', '', operator)

          return actionFactory<InitialValue, Value>(
            chain,
            initialActionId,
            runOperators
          )
        },
      }
    )
  }
}
