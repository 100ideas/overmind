import { BaseApp, TDerive } from './types'

export type SubType<Base, Condition> = Pick<
  Base,
  { [Key in keyof Base]: Base[Key] extends Condition ? Key : never }[keyof Base]
>

export type Options = {
  name?: string
  devtools?: string | boolean
}

type CacheMessage = {
  value: any
  paths: string[]
  updateCount: number
}

export enum EventType {
  DERIVED = 'derived',
  DERIVED_DIRTY = 'derived:dirty',
  COMPUTED = 'computed',
  COMPUTED_DIRTY = 'computed:dirty',
  REACTION_ADD = 'reaction:add',
  REACTION_UPDATE = 'reaction:update',
  REACTION_REMOVE = 'reaction:remove',
  COMPONENT_ADD = 'component:add',
  COMPONENT_UPDATE = 'component:update',
  COMPONENT_REMOVE = 'component:remove',
}

export interface Events {
  [EventType.DERIVED]: {
    path: string
    paths: string[]
    updateCount: number
    value: any
  }
  [EventType.DERIVED_DIRTY]: {
    path: string
    flushId: number
  }
  [EventType.COMPUTED]: {
    path: string
    updateCount: number
    cache: CacheMessage[]
    limit: number
  }
  [EventType.COMPUTED_DIRTY]: {
    path: string
    flushId: number
  }
  [EventType.REACTION_ADD]: {
    path: string
    statePath: string
    updateCount: number
  }
  [EventType.REACTION_UPDATE]: {
    path: string
    statePath: string
    updateCount: number
    flushId: number
  }
  [EventType.REACTION_REMOVE]: {
    path: string
    statePath: string
    updateCount: number
  }
  [EventType.COMPONENT_ADD]: {
    componentId: number
    componentInstanceId: number
    name: string
    paths: string[]
  }
  [EventType.COMPONENT_UPDATE]: {
    componentId: number
    componentInstanceId: number
    name: string
    paths: string[]
    flushId?: number
  }
  [EventType.COMPONENT_REMOVE]: {
    componentId: number
    componentInstanceId: number
    name: string
  }
}

// ============= PRIVATE TYPES FOR APP

export type TBaseContext<App extends BaseApp> = App['effects'] & {
  state: App['state']
}

export type ResolveState<State extends object> = {
  [P in keyof State]: State[P] extends TDerive<any, any>
    ? ReturnType<State[P]>
    : State[P] extends Array<any>
      ? State[P]
      : State[P] extends object ? ResolveState<State[P]> : State[P]
}

export type ResolveActions<Actions extends { [key: string]: any }> = {
  [T in keyof Actions]: Actions[T] extends Function
    ? ReturnType<Actions[T]>
    : {
        [P in keyof Actions[T]]: Actions[T][P] extends Function
          ? ReturnType<Actions[T][P]>
          : Actions[T][P]
      }
}
