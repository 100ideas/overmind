import {
  ActionBase,
  ActionChain,
  ActionExecution,
  StopExecution,
} from 'action-chain'
import { Mutation, ProxyStateTree } from 'proxy-state-tree'

type OperatorCallback<BaseContext, Value, NewValue = Value> = (
  ctx: BaseContext & {
    value: Value
  }
) => NewValue

export interface ValueAction<BaseContext, Value, ReturnValue = Value>
  extends ActionClass<BaseContext, Value, ReturnValue> {
  (value: Value): ReturnValue
}

export interface NoValueAction<BaseContext, Value, ReturnValue = Value>
  extends ActionClass<BaseContext, Value, ReturnValue> {
  (): ReturnValue
}

export interface Compose<BaseContext, Value, ReturnValue = Value> {
  (action: ActionClass<BaseContext, Value, Value>): [Value] extends [void]
    ? NoValueAction<BaseContext, Value, ReturnValue>
    : ValueAction<BaseContext, Value, ReturnValue>
}

interface MutationsEvents {
  mutations: ActionExecution & {
    mutations: Mutation[]
  }
}

export const createOperators = (proxyStateTree, actionChain) => ({
  fork: (cb, paths) =>
    new ActionClass(proxyStateTree, actionChain).fork(cb, paths),
  mutate: (cb) => new ActionClass(proxyStateTree, actionChain).mutate(cb),
  run: (cb) => new ActionClass(proxyStateTree, actionChain).run(cb),
  map: (cb) => new ActionClass(proxyStateTree, actionChain).map(cb),
  attempt: (cb, paths) =>
    new ActionClass(proxyStateTree, actionChain).attempt(cb, paths),
  when: (cb, paths) =>
    new ActionClass(proxyStateTree, actionChain).when(cb, paths),
  compose: (action) =>
    new ActionClass(proxyStateTree, actionChain).compose(action),
  parallel: (actions) =>
    new ActionClass(proxyStateTree, actionChain).parallel(actions),
  filter: (cb) => new ActionClass(proxyStateTree, actionChain).filter(cb),
  debounce: (ms) => new ActionClass(proxyStateTree, actionChain).debounce(ms),
})

export class ActionClass<
  BaseContext,
  InitialValue,
  Value = InitialValue
> extends ActionBase<BaseContext> {
  operators: any
  constructor(
    private proxyStateTree: ProxyStateTree,
    actionChain: ActionChain<BaseContext>,
    initialActionId?: number,
    runOperators?
  ) {
    super(actionChain, initialActionId, runOperators)
    this.operators = createOperators(this.proxyStateTree, this.getActionChain())
  }
  fork: <Paths>(
    cb: OperatorCallback<BaseContext, Value, keyof Paths>,
    paths: Paths
  ) => [InitialValue] extends [void]
    ? NoValueAction<BaseContext, InitialValue, Value>
    : ValueAction<BaseContext, InitialValue, Value> = (cb, paths) => {
    const actions = Object.keys(paths).reduce((aggr, key) => {
      aggr[key] = paths[key](this.operators)

      return aggr
    }, {})
    const operator = (ctx, value) => {
      const path = cb({
        ...ctx,
        value,
      })

      return (actions[path as any] as any).map(() => value)(value, ctx, path)
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'fork',
      (cb as any).displayName || cb.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  mutate: (
    cb: OperatorCallback<BaseContext, Value, any>
  ) => [InitialValue] extends [void]
    ? NoValueAction<BaseContext, InitialValue, Value>
    : ValueAction<BaseContext, InitialValue, Value> = (cb) => {
    const operator = (ctx, value) => {
      this.proxyStateTree.startMutationTracking()
      cb({
        ...ctx,
        value,
      })
      const mutations = this.proxyStateTree.clearMutationTracking()
      this.getActionChain<MutationsEvents>().emitAsync('mutations', {
        mutations,
        ...ctx.__execution,
      })

      return value
    }

    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'mutate',
      (cb as any).displayName || cb.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  run: (
    cb: OperatorCallback<BaseContext, Value, void | Promise<any>>
  ) => [InitialValue] extends [void]
    ? NoValueAction<BaseContext, InitialValue, Value>
    : ValueAction<BaseContext, InitialValue, Value> = (cb) => {
    const operator = (ctx, value) => {
      const result = cb({
        ...ctx,
        value,
      })

      if (result instanceof Promise) {
        return result.then(() => value)
      }

      return value
    }

    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'run',
      (cb as any).displayName || cb.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  map: <NewValue>(
    cb: OperatorCallback<BaseContext, Value, NewValue | Promise<NewValue>>
  ) => [InitialValue] extends [void]
    ? NoValueAction<BaseContext, InitialValue, NewValue>
    : ValueAction<BaseContext, InitialValue, NewValue> = (cb) => {
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'map',
      (cb as any).displayName || cb.name,
      (ctx, value) => cb({ ...ctx, value })
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  attempt: <ResolveValue, RejectValue, NewValue>(
    cb: OperatorCallback<BaseContext, Value, NewValue | Promise<NewValue>>,
    paths: {
      success: Compose<
        BaseContext,
        ReturnType<
          OperatorCallback<BaseContext, Value, NewValue | Promise<NewValue>>
        >,
        ResolveValue
      >
      error: Compose<
        BaseContext,
        ReturnType<
          OperatorCallback<BaseContext, Value, NewValue | Promise<NewValue>>
        >,
        RejectValue
      >
    }
  ) => [InitialValue] extends [void]
    ? NoValueAction<BaseContext, InitialValue, ResolveValue | RejectValue>
    : ValueAction<BaseContext, InitialValue, ResolveValue | RejectValue> = <
    ResolveValue,
    RejectValue
  >(
    cb,
    paths
  ) => {
    const successPath = (paths.success as any)(this.operators)
    const errorPath = (paths.error as any)(this.operators)
    const operator = (ctx, value) => {
      return (cb({
        ...ctx,
        value,
      }) as any)
        .then((promiseValue) => {
          return successPath(promiseValue, ctx, 'success')
        })
        .catch((error) => {
          return errorPath(error, ctx, 'error')
        })
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'attempt',
      (cb as any).displayName || cb.name,
      operator
    )

    return new ActionClass<BaseContext, Value, ResolveValue | RejectValue>(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  when: <TrueValue, FalseValue>(
    cb: OperatorCallback<BaseContext, Value, boolean>,
    paths: {
      true: Compose<BaseContext, Value, TrueValue>
      false: Compose<BaseContext, Value, FalseValue>
    }
  ) => [InitialValue] extends [void]
    ? NoValueAction<BaseContext, InitialValue, TrueValue | FalseValue>
    : ValueAction<BaseContext, InitialValue, TrueValue | FalseValue> = (
    cb,
    paths
  ) => {
    const trueAction = (paths.true as any)(this.operators)
    const falseAction = (paths.false as any)(this.operators)
    const operator = (ctx, value) => {
      const isTrue = cb({
        ...ctx,
        value,
      })
      const path = isTrue ? trueAction : falseAction
      return path(value, ctx, isTrue ? 'true' : 'false')
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'when',
      (cb as any).displayName || cb.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  compose: <T>(
    action: Compose<BaseContext, Value, T>
  ) => [InitialValue] extends [void]
    ? NoValueAction<BaseContext, InitialValue, T>
    : ValueAction<BaseContext, InitialValue, T> = (action) => {
    const composedAction = (action as any)(this.operators)
    const operator = (ctx, value) => {
      return composedAction(value, ctx)
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'compose',
      (action as any).dispayName || action.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  parallel: (
    actions: Compose<BaseContext, Value, any>[]
  ) => [InitialValue] extends [void]
    ? NoValueAction<BaseContext, InitialValue, Value>
    : ValueAction<BaseContext, InitialValue, Value> = (actions) => {
    const composedActions = actions.map((action) =>
      (action as any)(this.operators)
    )
    const operator = (ctx, value) => {
      return Promise.all(
        composedActions.map((composedAction, index) =>
          composedAction(
            value,
            ctx,
            (actions[index] as any).displayName || actions[index].name
          )
        )
      ).then(() => value)
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'parallel',
      '',
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  filter: (
    cb: OperatorCallback<BaseContext, Value, boolean>
  ) => [InitialValue] extends [void]
    ? NoValueAction<BaseContext, InitialValue, Value>
    : ValueAction<BaseContext, InitialValue, Value> = (cb) => {
    const operator = (ctx, value) => {
      const result = cb({
        ...ctx,
        value,
      })

      if (result === true) {
        return value
      }

      return new StopExecution(value)
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'filter',
      (cb as any).displayName || cb.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  debounce: (
    timer: number
  ) => [InitialValue] extends [void]
    ? NoValueAction<BaseContext, InitialValue, Value>
    : ValueAction<BaseContext, InitialValue, Value> = (timer) => {
    let currentTimeout = null

    const operator = (_, value) => {
      return new Promise((resolve) => {
        if (currentTimeout) {
          currentTimeout()
        }
        const timeoutId = setTimeout(() => {
          resolve(value)
          currentTimeout = null
        }, timer)
        currentTimeout = () => {
          clearTimeout(timeoutId)
          resolve(new StopExecution(value))
        }
      })
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'debounce',
      '',
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
}
