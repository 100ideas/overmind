import ProxyStateTree, { Mutation } from 'proxy-state-tree'
import {
  ActionBase,
  ActionExecution,
  StopExecution,
  ActionChain,
} from 'action-chain'

type OperatorCallback<State, Effects, Value, NewValue = Value> = (
  arg: {
    state: State
    effets: Effects
    value: Value
  }
) => NewValue | Promise<NewValue>

export interface IValueAction<
  State,
  Effects,
  InitialValue,
  Value = InitialValue
> extends ActionClass<State, Effects, InitialValue, Value> {
  (value: InitialValue): Value
}

export interface INoValueAction<
  State,
  Effects,
  InitialValue,
  Value = InitialValue
> extends ActionClass<State, Effects, InitialValue, Value> {
  (): Value
}

export type ReturnAction<Value, State, Effects> = [Value] extends [void]
  ? INoValueAction<State, Effects, Value>
  : IValueAction<State, Effects, Value>

export interface Compose<State, Effects, Value, ReturnValue = Value> {
  (action: ActionClass<State, Effects, Value, Value>): [Value] extends [void]
    ? INoValueAction<State, Effects, Value, ReturnValue>
    : IValueAction<State, Effects, Value, ReturnValue>
}

interface MutationsEvents {
  mutations: ActionExecution & {
    mutations: Mutation[]
  }
}

export const createOperators = (proxyStateTree, actionChain) => ({
  fork: (cb, paths) =>
    new ActionClass(proxyStateTree, actionChain).fork(cb, paths),
  mutate: (cb) => new ActionClass(proxyStateTree, actionChain).mutate(cb),
  run: (cb) => new ActionClass(proxyStateTree, actionChain).run(cb),
  map: (cb) => new ActionClass(proxyStateTree, actionChain).map(cb),
  attempt: (cb, paths) =>
    new ActionClass(proxyStateTree, actionChain).attempt(cb, paths),
  when: (cb, paths) =>
    new ActionClass(proxyStateTree, actionChain).when(cb, paths),
  compose: (action) =>
    new ActionClass(proxyStateTree, actionChain).compose(action),
  parallel: (actions) =>
    new ActionClass(proxyStateTree, actionChain).parallel(actions),
  filter: (cb) => new ActionClass(proxyStateTree, actionChain).filter(cb),
  debounce: (ms) => new ActionClass(proxyStateTree, actionChain).debounce(ms),
})

export default class ActionClass<
  State,
  Effects,
  InitialValue,
  Value = InitialValue
> extends ActionBase<Effects> {
  operators: any
  constructor(
    private proxyStateTree: ProxyStateTree,
    actionChain: ActionChain<Effects>,
    initialActionId?: number,
    runOperators?
  ) {
    super(actionChain, initialActionId, runOperators)
    this.operators = createOperators(this.proxyStateTree, this.getActionChain())
  }
  fork: <Paths>(
    cb: (
      arg: {
        state: State
        effects: Effects
        value: Value
      }
    ) => keyof Paths,
    paths: Paths
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (cb, paths) => {
    const actions = Object.keys(paths).reduce((aggr, key) => {
      aggr[key] = paths[key](this.operators)

      return aggr
    }, {})
    const operator = (arg, value) => {
      const path = cb({
        ...arg,
        value,
      })

      return (actions[path as any] as any).map(() => value)(value, arg, path)
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'fork',
      (cb as any).displayName || cb.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  mutate: (
    cb: (
      arg: {
        state: State
        value: Value
      }
    ) => any
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (cb) => {
    const operator = (arg, value) => {
      this.proxyStateTree.startMutationTracking()
      cb({
        ...arg,
        value,
      })
      const mutations = this.proxyStateTree.clearMutationTracking()
      this.getActionChain<MutationsEvents>().emitAsync('mutations', {
        mutations,
        ...arg.__execution,
      })

      return value
    }

    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'mutate',
      (cb as any).displayName || cb.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  run: (
    cb: (
      arg: {
        state: State
        effects: Effects
        value: Value
      }
    ) => void | Promise<any>
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (cb) => {
    const operator = (arg, value) => {
      const result = cb({
        ...arg,
        value,
      })

      if (result instanceof Promise) {
        return result.then(() => value)
      }

      return value
    }

    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'run',
      (cb as any).displayName || cb.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  map: <NewValue>(
    cb: (
      arg: {
        state: State
        effects: Effects
        value: Value
      }
    ) => NewValue | Promise<NewValue>
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, NewValue>
    : IValueAction<State, Effects, InitialValue, NewValue> = (cb) => {
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'map',
      (cb as any).displayName || cb.name,
      (arg, value) => cb({ ...arg, value })
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  attempt: <ResolveValue, RejectValue, NewValue>(
    cb: OperatorCallback<State, Effects, Value, NewValue>,
    paths: {
      success: Compose<
        State,
        Effects,
        ReturnType<OperatorCallback<State, Effects, Value, NewValue>>,
        ResolveValue
      >
      error: Compose<
        State,
        Effects,
        ReturnType<OperatorCallback<State, Effects, Value, NewValue>>,
        RejectValue
      >
    }
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, ResolveValue | RejectValue>
    : IValueAction<State, Effects, InitialValue, ResolveValue | RejectValue> = <
    ResolveValue,
    RejectValue
  >(
    cb,
    paths
  ) => {
    const successPath = (paths.success as any)(this.operators)
    const errorPath = (paths.error as any)(this.operators)
    const operator = (arg, value) => {
      return (cb({
        ...arg,
        value,
      }) as any)
        .then((promiseValue) => {
          return successPath(promiseValue, arg, 'success')
        })
        .catch((error) => {
          return errorPath(error, arg, 'error')
        })
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'attempt',
      (cb as any).displayName || cb.name,
      operator
    )

    return new ActionClass<State, Effects, Value, ResolveValue | RejectValue>(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  when: <TrueValue, FalseValue>(
    cb: (
      arg: {
        state: State
        effects: Effects
        value: Value
      }
    ) => boolean,
    paths: {
      true: Compose<State, Effects, Value, TrueValue>
      false: Compose<State, Effects, Value, FalseValue>
    }
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, TrueValue | FalseValue>
    : IValueAction<State, Effects, InitialValue, TrueValue | FalseValue> = (
    cb,
    paths
  ) => {
    const trueAction = (paths.true as any)(this.operators)
    const falseAction = (paths.false as any)(this.operators)
    const operator = (arg, value) => {
      const isTrue = cb({
        ...arg,
        value,
      })
      const path = isTrue ? trueAction : falseAction
      return path(value, arg, isTrue ? 'true' : 'false')
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'when',
      (cb as any).displayName || cb.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  compose: <T>(
    action: Compose<State, Effects, Value, T>
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, T>
    : IValueAction<State, Effects, InitialValue, T> = (action) => {
    const composedAction = (action as any)(this.operators)
    const operator = (arg, value) => {
      return composedAction(value, arg)
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'compose',
      (action as any).dispayName || action.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  parallel: (
    actions: Compose<State, Effects, Value, any>[]
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (actions) => {
    const composedActions = actions.map((action) =>
      (action as any)(this.operators)
    )
    const operator = (arg, value) => {
      return Promise.all(
        composedActions.map((composedAction, index) =>
          composedAction(
            value,
            arg,
            (actions[index] as any).displayName || actions[index].name
          )
        )
      ).then(() => value)
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'parallel',
      '',
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  filter: (
    cb: (
      arg: {
        state: State
        effects: Effects
        value: Value
      }
    ) => boolean
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (cb) => {
    const operator = (arg, value) => {
      const result = cb({
        ...arg,
        value,
      })

      if (result === true) {
        return value
      }

      return new StopExecution(value)
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'filter',
      (cb as any).displayName || cb.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  debounce: (
    timer: number
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (timer) => {
    let currentTimeout = null

    const operator = (_, value) => {
      return new Promise((resolve) => {
        if (currentTimeout) {
          currentTimeout()
        }
        const timeoutId = setTimeout(() => {
          resolve(value)
          currentTimeout = null
        }, timer)
        currentTimeout = () => {
          clearTimeout(timeoutId)
          resolve(new StopExecution(value))
        }
      })
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'debounce',
      '',
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
}
