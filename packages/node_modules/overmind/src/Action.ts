import ProxyStateTree from 'proxy-state-tree'
import { ActionBase, StopExecution } from 'action-chain'

type OperatorCallback<Context, Value, NewValue = Value> = (
  value: Value,
  context: Context
) => NewValue | Promise<NewValue>

export interface IValueAction<
  State,
  Context,
  InitialValue,
  Value = InitialValue
> extends Action<State, Context, InitialValue, Value> {
  (value: InitialValue): Value
}

export interface INoValueAction<
  State,
  Context,
  InitialValue,
  Value = InitialValue
> extends Action<State, Context, InitialValue, Value> {
  (): Value
}

export default class Action<
  State,
  Context,
  InitialValue,
  Value = InitialValue
> extends ActionBase<Context, InitialValue, Value> {
  private proxyStateTree: ProxyStateTree
  constructor(proxyStateTree, actionChain, initialActionId?, runOperators?) {
    super(actionChain, initialActionId, runOperators)
    this.proxyStateTree = proxyStateTree
  }
  fork: <Paths>(
    cb: (value: Value, context: Context) => keyof Paths,
    paths: Paths
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Context, InitialValue, Value>
    : IValueAction<State, Context, InitialValue, Value> = (cb, paths) => {
    const operator = (value, context) => {
      const path = cb(value, context)

      return (paths[path] as any).map(() => value)(value, context, path)
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'fork',
      cb.name,
      operator
    )

    return new Action(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  mutation: (
    cb: (value: Value, state: State) => any
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Context, InitialValue, Value>
    : IValueAction<State, Context, InitialValue, Value> = (cb) => {
    const operator = (value, context) => {
      this.proxyStateTree.startMutationTracking()
      cb(value, context.state)
      const mutations = this.proxyStateTree.clearMutationTracking()
      this.getActionChain().emit('mutations', {
        mutations,
        ...context.__execution,
      })

      return value
    }

    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'mutation',
      cb.name,
      operator
    )

    return new Action(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  do: (
    cb: (value: Value, context: Context) => void
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Context, InitialValue, Value>
    : IValueAction<State, Context, InitialValue, Value> = (cb) => {
    const operator = (value, context) => {
      cb(value, context)
      return value
    }

    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'do',
      cb.name,
      operator
    )

    return new Action(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  map: <NewValue>(
    cb: (value: Value, context: Context) => NewValue | Promise<NewValue>
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Context, InitialValue, NewValue>
    : IValueAction<State, Context, InitialValue, NewValue> = (cb) => {
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'map',
      cb.name,
      cb
    )

    return new Action(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  try: <ResolveValue, RejectValue, NewValue>(
    cb: OperatorCallback<Context, Value, NewValue>,
    paths: {
      success: Action<
        State,
        Context,
        ReturnType<OperatorCallback<Context, Value, NewValue>>,
        ResolveValue
      >
      error: Action<
        State,
        Context,
        ReturnType<OperatorCallback<Context, Value, NewValue>>,
        RejectValue
      >
    }
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Context, InitialValue, ResolveValue | RejectValue>
    : IValueAction<State, Context, InitialValue, ResolveValue | RejectValue> = <
    ResolveValue,
    RejectValue,
    NewValue
  >(
    cb,
    paths
  ) => {
    const operator = (value, context) => {
      return (cb(value, context) as any)
        .then((promiseValue) => {
          return (paths.success as any)(promiseValue, context, 'success')
        })
        .catch((error) => {
          return (paths.error as any)(error, context, 'error')
        })
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'try',
      cb.name,
      operator
    )

    return new Action<State, Context, Value, ResolveValue | RejectValue>(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  when: <TrueValue, FalseValue>(
    cb: (value: Value, context: Context) => boolean,
    paths: {
      true: Action<State, Context, Value, TrueValue>
      false: Action<State, Context, Value, FalseValue>
    }
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Context, InitialValue, TrueValue | FalseValue>
    : IValueAction<State, Context, InitialValue, TrueValue | FalseValue> = (
    cb,
    paths
  ) => {
    const operator = (value, context) => {
      const isTrue = cb(value, context)
      const path = isTrue ? paths.true : (paths.false as any)

      return path(value, context, isTrue ? 'true' : 'false')
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'when',
      cb.name,
      operator
    )

    return new Action(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  filter: (
    cb: (value: Value, context: Context) => boolean
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Context, InitialValue, Value>
    : IValueAction<State, Context, InitialValue, Value> = (cb) => {
    const operator = (value, context) => {
      const result = cb(value, context)

      if (result === true) {
        return value
      }

      return new StopExecution(value)
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'filter',
      cb.name,
      operator
    )

    return new Action(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  debounce: (
    timer: number
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Context, InitialValue, Value>
    : IValueAction<State, Context, InitialValue, Value> = (timer) => {
    let currentTimeout = null

    const operator = (value) => {
      return new Promise((resolve) => {
        if (currentTimeout) {
          currentTimeout()
        }
        const timeoutId = setTimeout(() => {
          resolve(value)
          currentTimeout = null
        }, timer)
        currentTimeout = () => {
          clearTimeout(timeoutId)
          resolve(new StopExecution(value))
        }
      })
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'debounce',
      '',
      operator
    )

    return new Action(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
}
