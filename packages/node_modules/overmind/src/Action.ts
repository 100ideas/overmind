import ProxyStateTree, { Mutation } from 'proxy-state-tree'
import {
  ActionBase,
  ActionExecution,
  StopExecution,
  ActionChain,
} from 'action-chain'

type OperatorCallback<Effects, Value, NewValue = Value> = (
  effects: Effects,
  value: Value
) => NewValue | Promise<NewValue>

export interface IValueAction<
  State,
  Effects,
  InitialValue,
  Value = InitialValue
> extends ActionClass<State, Effects, InitialValue, Value> {
  (value: InitialValue): Value
}

export interface INoValueAction<
  State,
  Effects,
  InitialValue,
  Value = InitialValue
> extends ActionClass<State, Effects, InitialValue, Value> {
  (): Value
}

export interface Compose<State, Effects, Value, ReturnValue = Value> {
  (
    action: () => [Value] extends [void]
      ? INoValueAction<State, Effects & { state: State }, Value>
      : IValueAction<State, Effects & { state: State }, Value>
  ): [Value] extends [void]
    ? INoValueAction<State, Effects & { state: State }, Value, ReturnValue>
    : IValueAction<State, Effects & { state: State }, Value, ReturnValue>
}

interface MutationsEvents {
  mutations: ActionExecution & {
    mutations: Mutation[]
  }
}

export default class ActionClass<
  State,
  Effects,
  InitialValue,
  Value = InitialValue
> extends ActionBase<Effects> {
  constructor(
    private proxyStateTree: ProxyStateTree,
    actionChain: ActionChain<Effects>,
    initialActionId?: number,
    runOperators?
  ) {
    super(actionChain, initialActionId, runOperators)
  }
  fork: <Paths>(
    cb: (effects: Effects, value: Value) => keyof Paths,
    paths: Paths
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (cb, paths) => {
    const actions = Object.keys(paths).reduce((aggr, key) => {
      aggr[key] = paths[key](
        () => new ActionClass(this.proxyStateTree, this.getActionChain())
      )

      return aggr
    }, {})
    const operator = (effects, value) => {
      const path = cb(effects, value)

      return (actions[path as any] as any).map(() => value)(
        value,
        effects,
        path
      )
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'fork',
      cb.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  mutate: (
    cb: (state: State, value: Value) => any
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (cb) => {
    const operator = (effects, value) => {
      this.proxyStateTree.startMutationTracking()
      cb(effects.state, value)
      const mutations = this.proxyStateTree.clearMutationTracking()
      this.getActionChain<MutationsEvents>().emitAsync('mutations', {
        mutations,
        ...effects.__execution,
      })

      return value
    }

    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'mutate',
      cb.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  do: (
    cb: (effects: Effects, value: Value) => void
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (cb) => {
    const operator = (effects, value) => {
      cb(effects, value)
      return value
    }

    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'do',
      cb.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  map: <NewValue>(
    cb: (effects: Effects, value: Value) => NewValue | Promise<NewValue>
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, NewValue>
    : IValueAction<State, Effects, InitialValue, NewValue> = (cb) => {
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'map',
      cb.name,
      cb
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  try: <ResolveValue, RejectValue, NewValue>(
    cb: OperatorCallback<Effects, Value, NewValue>,
    paths: {
      success: Compose<
        State,
        Effects,
        ReturnType<OperatorCallback<Effects, Value, NewValue>>,
        ResolveValue
      >
      error: Compose<
        State,
        Effects,
        ReturnType<OperatorCallback<Effects, Value, NewValue>>,
        RejectValue
      >
    }
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, ResolveValue | RejectValue>
    : IValueAction<State, Effects, InitialValue, ResolveValue | RejectValue> = <
    ResolveValue,
    RejectValue
  >(
    cb,
    paths
  ) => {
    const successPath = paths.success(
      () => new ActionClass(this.proxyStateTree, this.getActionChain())
    )
    const errorPath = paths.error(
      () => new ActionClass(this.proxyStateTree, this.getActionChain())
    )
    const operator = (effects, value) => {
      return (cb(effects, value) as any)
        .then((promiseValue) => {
          return successPath(promiseValue, effects, 'success')
        })
        .catch((error) => {
          return errorPath(error, effects, 'error')
        })
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'try',
      cb.name,
      operator
    )

    return new ActionClass<State, Effects, Value, ResolveValue | RejectValue>(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  when: <TrueValue, FalseValue>(
    cb: (effects: Effects, value: Value) => boolean,
    paths: {
      true: Compose<State, Effects, Value, TrueValue>
      false: Compose<State, Effects, Value, FalseValue>
    }
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, TrueValue | FalseValue>
    : IValueAction<State, Effects, InitialValue, TrueValue | FalseValue> = (
    cb,
    paths
  ) => {
    const trueAction = (paths.true as any)(
      () => new ActionClass(this.proxyStateTree, this.getActionChain())
    )
    const falseAction = (paths.false as any)(
      () => new ActionClass(this.proxyStateTree, this.getActionChain())
    )
    const operator = (effects, value) => {
      const isTrue = cb(effects, value)
      const path = isTrue ? trueAction : falseAction
      return path(value, effects, isTrue ? 'true' : 'false')
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'when',
      cb.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  compose: <T>(
    action: Compose<State, Effects, Value, T>
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, T>
    : IValueAction<State, Effects, InitialValue, T> = (action) => {
    const composedAction = (action as any)(
      () => new ActionClass(this.proxyStateTree, this.getActionChain())
    )
    const operator = (effects, value) => {
      return composedAction(value, effects)
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'compose',
      action.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  filter: (
    cb: (effects: Effects, value: Value) => boolean
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (cb) => {
    const operator = (effects, value) => {
      const result = cb(effects, value)

      if (result === true) {
        return value
      }

      return new StopExecution(value)
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'filter',
      cb.name,
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  debounce: (
    timer: number
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (timer) => {
    let currentTimeout = null

    const operator = (_, value) => {
      return new Promise((resolve) => {
        if (currentTimeout) {
          currentTimeout()
        }
        const timeoutId = setTimeout(() => {
          resolve(value)
          currentTimeout = null
        }, timer)
        currentTimeout = () => {
          clearTimeout(timeoutId)
          resolve(new StopExecution(value))
        }
      })
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'debounce',
      '',
      operator
    )

    return new ActionClass(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
}
