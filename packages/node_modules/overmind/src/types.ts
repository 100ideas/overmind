import { ResolveActions, ResolveState, TBaseContext } from './internalTypes'
import { Overmind } from './'

/** ===== PUBLIC API
 */
export { EventType } from './internalTypes'

export type Configuration = {
  onInitialize?: any
  state?: {}
  effects?: {}
  actions?: {}
  reactions?: {}
}

export type BaseApp = {
  state: {}
  effects: {}
  actions: {}
}

export interface TConfig<Config extends Configuration> {
  state: Config['state'] & {}
  actions: Config['actions']
  effects: Config['effects'] & {}
}

// This is the type of the `app` argument passed in components.
export type TApp<Config extends Configuration> = {
  // Resolves `Derive` types in state.
  state: ResolveState<Config['state'] & {}>
  actions: ResolveActions<Config['actions']>
  reaction: (
    name: string,
    stateCb: (state: TApp<Config>['state']) => any,
    Function
  ) => void
}

// This is the type of the argument passed in actions.
export type TValueContext<Config extends Configuration, Value> = TBaseContext<
  Config
> & {
  value: Value
}

export type TAction<Config extends Configuration, Value> = (
  context: TValueContext<Config, Value>
) => any

export type TOperator<Config extends Configuration, Input, Output> = (
  err: Error | null,
  val: TValueContext<Config, Input>,
  next: (err: Error | null, val?: TValueContext<Config, Output>) => void,
  final?: (err, Error, val?: TValueContext<Config, Output>) => void
) => void

export type TDerive<
  Config extends Configuration,
  Parent extends object,
  Value
> = (
  parent: ResolveState<Parent>,
  state: ResolveState<Config['state'] & {}>
) => Value

export type TReaction<Config extends Configuration> = (
  reaction: (
    getState: (state: ResolveState<Config['state'] & {}>) => any,
    action: TAction<Config, void> | TOperator<Config, void, any>
  ) => any
) => any

export type TOnInitialize<Config extends Configuration> = (
  context: TValueContext<Config, Overmind<Config>>
) => void
