import { ResolveActions, ResolveState, TBaseContext } from './internalTypes'
import { Operator } from './'

/** ===== PUBLIC API
 */
export { EventType } from './internalTypes'

export type Configuration = {
  onInitialize?: any
  state?: {}
  effects?: {}
  actions?: {}
  reactions?: {}
}

export type BaseApp = {
  state: {}
  effects: {}
  actions: {}
}

export interface TApp<Config extends Configuration> {
  // Resolves `Derive` types in state.
  state: ResolveState<Config['state'] & {}>
  // Transform actions into callable functions.
  actions: ResolveActions<Config['actions']>
  effects: Config['effects'] & {}
}

export type TContext<App extends BaseApp> = TBaseContext<App>

export type TValueContext<
  BaseContext extends TContext<any>,
  Value
> = BaseContext & {
  value: Value
}

export type TAction<App extends BaseApp, Value> = (
  context: TValueContext<TContext<App>, Value>
) => any

export type TOperator<Input, Output, OperatorContext extends TContext<any>> = (
  err: Error | null,
  val: TValueContext<OperatorContext, Input>,
  next: (
    err: Error | null,
    val?: TValueContext<OperatorContext, Output>
  ) => void,
  final?: (err, Error, val?: TValueContext<OperatorContext, Output>) => void
) => void

export type TDerive<App extends BaseApp, Value, Parent extends object = {}> = (
  state: App['state'],
  parent: ResolveState<Parent>
) => Value

export type TReaction<App extends BaseApp> = (
  reaction: (
    getState: (state: App['state']) => any,
    action: TAction<App, void> | TOperator<void, any, TContext<App>>
  ) => any
) => any
