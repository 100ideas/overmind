import { ActionClass, Compose, NoValueAction } from './Action'
import { ResolveActions, ResolveState, TBaseContext } from './internalTypes'

/** ===== PUBLIC API
 */
export { EventType } from './internalTypes'

export type Configuration = {
  onInitialize?: any
  state?: {}
  effects?: {}
  actions?: {}
  reactions?: {}
}

export type BaseApp = {
  state: {}
  effects: {}
  actions: {}
}

export interface TApp<Config extends Configuration> {
  // Resolves `Derive` types in state.
  state: ResolveState<Config['state'] & {}>
  // Transform actions into callable functions.
  actions: ResolveActions<Config['actions'] & {}>
  effects: Config['effects'] & {}
}

export type TContext<App extends BaseApp, Value> = TBaseContext<App> & {
  value: Value
}

export type TAction<App extends BaseApp, Value, ReturnValue = Value> = Compose<
  TBaseContext<App>,
  Value,
  ReturnValue
>

export namespace TOperation {
  export type Mutate<App extends BaseApp, Value = any> = (
    ctx: TContext<App, Value>
  ) => void
  export type Filter<App extends BaseApp, Value = any> = (
    ctx: TContext<App, Value>
  ) => boolean
  export type Map<App extends BaseApp, Value, ReturnValue = Value> = (
    ctx: TContext<App, Value>
  ) => ReturnValue
  export type When<App extends BaseApp, Value = any> = (
    ctx: TContext<App, Value>
  ) => boolean
  export type Run<App extends BaseApp, Value = any> = (
    ctx: TContext<App, Value>
  ) => void
  export type Fork<App extends BaseApp, Value = any> = (
    ctx: TContext<App, Value>
  ) => string
  export type Attempt<App extends BaseApp, Value, ReturnValue> = (
    ctx: TContext<App, Value>
  ) => ReturnValue
}

export type TDerive<App extends BaseApp, Value> = (state: App['state']) => Value

export type TReaction<App extends BaseApp> = (
  reaction: (
    getState: (state: App['state']) => any,
    action: NoValueAction<TBaseContext<App>, undefined>
  ) => any,
  action: ActionClass<TBaseContext<App>, undefined>
) => any
