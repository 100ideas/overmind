import * as React from 'react'
import App, { ActionsCallback } from '../'
export { TContext, IAction } from '../'

export type IReactComponent<P = any> =
  | React.StatelessComponent<P>
  | React.ComponentClass<P>
  | React.ClassicComponentClass<P>

export type TConnect<State = {}, Actions = {}> = {
  appState: State
  actions: Actions
}

// Diff / Omit taken from https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-311923766
type Omit<T, K extends keyof T> = Pick<
  T,
  ({ [P in keyof T]: P } &
    { [P in K]: never } & { [x: string]: never; [x: number]: never })[keyof T]
>

export default class ReactApp<
  State extends object,
  Providers extends object,
  Actions extends
    | {
        [namespace: string]: ActionsCallback<Providers, State>
      }
    | ActionsCallback<Providers, State>
> extends App<State, Providers, Actions> {
  connect<
    Props,
    ConnectedActions = Actions extends {
      [namespace: string]: ActionsCallback<Providers, State>
    }
      ? { [Namespace in keyof Actions]: ReturnType<Actions[Namespace]> }
      : Actions extends ActionsCallback<Providers, State>
        ? ReturnType<Actions>
        : any
  >(
    Component: IReactComponent<Props & TConnect<State, ConnectedActions>>
  ): IReactComponent<
    Omit<
      Props & TConnect<State, ConnectedActions>,
      keyof TConnect<State, ConnectedActions>
    >
  > {
    const instance = this
    const isClassComponent = typeof Component.prototype.render === 'function'

    if (isClassComponent) {
      const originalRender = Component.prototype.render
      const originalWillUnmount = Component.prototype.componentWillUnmount

      Component.prototype.componentWillUnmount = function() {
        this.__mutationListener && this.__mutationListener.dispose()
        originalWillUnmount && originalWillUnmount.call(this)
      }
      Component.prototype.render = function() {
        const trackId = instance.trackState()
        const value = originalRender.call(this)
        const paths = instance.clearTrackState(trackId)

        if (this.__mutationListener) {
          this.__mutationListener.update(paths)
        } else {
          this.__mutationListener = instance.addMutationListener(
            Component.name || '',
            paths,
            () => {
              this.forceUpdate()
            }
          )
        }

        if (instance.devtools) {
          instance.devtools.send({
            type: 'component',
            data: {
              name: Component.name || '',
              paths: Array.from(paths),
            },
          })
        }
        return value
      }
    }

    return class extends React.PureComponent<
      Omit<
        Props & TConnect<State, ConnectedActions>,
        keyof TConnect<State, ConnectedActions>
      >
    > {
      __mutationListener: any
      componentWillUnmount() {
        this.__mutationListener && this.__mutationListener.dispose()
      }
      renderStatelessComponent() {
        const trackId = instance.trackState()
        const value = (Component as any)(
          Object.assign({}, this.props, {
            appState: instance.state,
            actions: instance.actions,
          }),
          this.context
        )
        const paths = instance.clearTrackState(trackId)
        if (this.__mutationListener) {
          this.__mutationListener.update(paths)
        } else {
          this.__mutationListener = instance.addMutationListener(
            Component.name || '',
            paths,
            () => {
              this.forceUpdate()
            }
          )
        }

        if (instance.devtools) {
          instance.devtools.send({
            type: 'component',
            data: {
              name: Component.name || '',
              paths: Array.from(paths),
            },
          })
        }

        return value
      }
      renderClassComponent() {
        return React.createElement(Component, Object.assign({}, this.props, {
          appState: instance.state,
          actions: instance.actions,
        }) as any)
      }
      render() {
        if (isClassComponent) {
          return this.renderClassComponent()
        }

        return this.renderStatelessComponent()
      }
    }
  }
}
