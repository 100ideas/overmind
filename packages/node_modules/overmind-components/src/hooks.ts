import { Component } from './Component'

export function useState<T>(initialState: T): [T, (update: T) => void] {
  const component = Component.current
  const existingHook = component.getHook()

  if (existingHook) {
    component.nextHookIndex++
    return existingHook
  }

  const hook = [
    initialState,
    (newState) => {
      hook[0] = newState
      component.reconcile(component, true)
    },
  ]

  component.addHook(hook)

  return hook as any
}

export function useEffect(effect, mem?) {
  const component = Component.current
  const existingHook = component.getHook()

  if (existingHook) {
    existingHook.unsubscribe && existingHook.unsubscribe()
    component.mountListeners.delete(existingHook.updateListener)
    component.reconcileListeners.delete(existingHook.updateListener)
    component.unmountListeners.delete(existingHook.unmountListener)
  }

  const hook = {
    unsubscribe: () => {},
    updateListener:
      existingHook && mem
        ? () => {
            if (
              mem.reduce(
                (aggr, val, index) =>
                  aggr ? val === existingHook.mem[index] : false,
                true
              )
            ) {
              return
            }
            hook.unsubscribe = effect()
          }
        : () => {
            hook.unsubscribe = effect()
          },
    unmountListener: () => {
      hook.unsubscribe && hook.unsubscribe()
    },
    mem,
  }

  component.mountListeners.add(hook.updateListener)
  component.reconcileListeners.add(hook.updateListener)
  component.unmountListeners.add(hook.unmountListener)

  component.addHook(hook)
}

export function useRef() {
  const existingHook = Component.current.getHook()

  if (existingHook) {
    Component.current.nextHookIndex++
    return existingHook
  }

  let hook = (node) => {
    ;(hook as any).target = node
  }

  Component.current.addHook(hook)

  return hook
}
