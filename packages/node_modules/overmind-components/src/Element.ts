export class Element {
  tag: any
  props: any
  children: any
  el: any
  parent: any
  context: any
  keys: any
  events: any
  constructor(tag, props, children) {
    this.tag = tag
    this.props = props || {}
    this.children = children
    this.keys = {}
    this.events = {}
  }
  mount(parent, context) {
    this.parent = parent
    this.context = context
    this.el =
      typeof this.tag === 'string'
        ? context.factory.createElement(this.tag)
        : this.tag

    for (var x = 0; x < this.children.length; x++) {
      const child = this.children[x]
      this.addKey(child)
      const el = child.mount(this, context).getElement()
      el && this.el.appendChild(el)
    }

    for (let prop in this.props) {
      this.updateAttribute(prop, null, this.props[prop])
    }

    return this
  }
  reconcile(next) {
    for (let prop in next.props) {
      if (this.props[prop] !== next.props[prop]) {
        this.updateAttribute(prop, this.props[prop], next.props[prop])
      }
    }
    for (let prop in this.props) {
      if (!next.props || !(prop in next.props)) {
        this.removeAttribute(prop)
      }
    }

    this.props = next.props

    /*
      Keys are currently used to cache children, though could also be used
      to evaluate the need to replaceChild as later removeChild actually puts
      stuff in the right spot... but not sure if it really is necessary
    */
    const prevKeys = this.keys
    this.keys = {}

    let x = 0

    for (x; x < next.children.length; x++) {
      const prevChild = this.children[x]
      const nextChild = next.children[x]
      let cachedChild

      if (
        nextChild.props &&
        'key' in nextChild.props &&
        prevKeys[nextChild.props.key] &&
        prevKeys[nextChild.props.key].tag === nextChild.tag
      ) {
        cachedChild = prevKeys[nextChild.props.key]
      } else {
        cachedChild = nextChild
      }

      if (!prevChild) {
        this.children[x] = cachedChild
        if (cachedChild === nextChild) {
          cachedChild.mount(this, this.context)
        } else {
          cachedChild.reconcile(nextChild)
        }

        this.el.appendChild(cachedChild.getElement())

        this.addKey(cachedChild)

        continue
      }

      if (
        prevChild.tag === nextChild.tag &&
        this.hasNoOrEqualKeys(prevChild, nextChild)
      ) {
        prevChild.reconcile(nextChild)
      } else {
        this.children[x] = cachedChild

        if (cachedChild === nextChild) {
          prevChild.unmount()
          cachedChild.mount(this, this.context)
        } else {
          cachedChild.reconcile(nextChild)
        }

        this.addKey(cachedChild)

        const el = cachedChild.getElement()
        if (el && prevChild.isNull()) {
          const insertBefore = this.getNextChildElement(cachedChild)
          this.el.insertBefore(el, insertBefore)
        } else if (el && prevChild.getElement()) {
          this.el.replaceChild(el, prevChild.getElement())
        } else if (el) {
          this.el.appendChild(el)
        } else if (prevChild.getElement()) {
          this.el.removeChild(prevChild.getElement())
        }
      }
    }

    const remainingChildren = this.children.splice(x)
    for (let x = 0; x < remainingChildren.length; x++) {
      const child = remainingChildren[x]
      const el = child.unmount().getElement()
      this.el.removeChild(el)
    }

    return this
  }
  addKey(child) {
    if (child.props && 'key' in child.props) {
      this.keys[child.props.key] = child
    }
  }
  hasNoOrEqualKeys(prevChild, nextChild) {
    if (
      !prevChild.props ||
      !nextChild.props ||
      !('key' in prevChild.props) ||
      !('key' in nextChild.props) ||
      (prevChild.props.key === nextChild.props.key &&
        prevChild.tag === nextChild.tag)
    ) {
      return true
    }

    return false
  }
  reconcileChildComponent(component, prevChild, nextChild) {
    if (prevChild.tag === nextChild.tag) {
      prevChild.reconcile(nextChild)

      return prevChild
    } else {
      prevChild.unmount()
      nextChild.mount(component, component.context)
      const el = nextChild.getElement()
      if (el && prevChild.isNull()) {
        const insertBefore = this.getNextChildElement(component)
        this.el.insertBefore(el, insertBefore)
      } else if (el) {
        this.el.replaceChild(el, component.getElement())
      } else {
        this.el.removeChild(component.getElement())
      }

      return nextChild
    }
  }
  updateAttribute(attr, prevValue, nextValue) {
    if (this.context.events.isEventAttr(attr)) {
      this.context.events.register(
        attr.substr(2).toLowerCase(),
        this.el,
        nextValue
      )

      return
    }

    switch (attr) {
      case 'key':
        return
      case 'value':
        this.el.value = nextValue
        break
      case 'ref':
        nextValue(this.el)
        break
      case 'style':
        for (let key in nextValue) {
          if (!prevValue || prevValue[key] !== nextValue[key]) {
            this.el.style[key] = nextValue[key]
          }
        }

        if (prevValue) {
          for (let key in prevValue) {
            if (!(key in nextValue)) {
              this.el.style[key] = null
            }
          }
        }
        break
      case 'dangerouslySetInnerHTML':
        this.el.innerHTML = nextValue.__html
        break
      case 'className':
        this.el.setAttribute('class', nextValue)
        break
      default:
        this.el.setAttribute(attr, nextValue)
    }
  }
  removeAttribute(attr) {
    switch (attr) {
      case 'key':
        return
      case 'ref':
        return
      case 'style':
        this.el.style = null
        break
      case 'dangerouslySetInnerHTML':
        //
        break
      case 'className':
        this.el.removeAttribute('class')
        break
      default:
        this.el.removeAttribute(attr)
    }
  }
  getNextChildElement(child) {
    const index = this.children.indexOf(child) + 1

    for (let x = index; x < this.children.length; x++) {
      if (this.children[x].isNull()) {
        continue
      }

      return this.children[x].el
    }

    return null
  }
  isNull() {
    return false
  }
  getElement() {
    return this.el
  }
  unmount() {
    for (let eventType in this.events) {
      this.el.removeEventListener(eventType, this.events[eventType])
    }

    return this
  }
}
