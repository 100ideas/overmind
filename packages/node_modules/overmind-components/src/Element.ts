export class Element {
  tag: any
  props: any
  children: any
  el: any
  parent: any
  context: any
  keys: any
  isMounted: boolean = false
  constructor(tag, props, children) {
    this.tag = tag
    this.props = props || {}
    this.children = children
    this.keys = {}
  }
  mount(parent, context) {
    this.parent = parent
    this.context = context

    this.el =
      typeof this.tag === 'string'
        ? context.factory.createElement(this.tag)
        : this.tag

    for (let prop in this.props) {
      this.updateAttribute(prop, null, this.props[prop])
    }

    for (var x = 0; x < this.children.length; x++) {
      const child = this.children[x]
      this.addKey(child)
      const el = child.mount(this, context).getElement()

      el && this.el.appendChild(el)
    }

    this.isMounted = true

    return this
  }
  reconcile(next) {
    for (let prop in next.props) {
      if (this.props[prop] !== next.props[prop]) {
        this.updateAttribute(prop, this.props[prop], next.props[prop])
      }
    }
    for (let prop in this.props) {
      if (!next.props || !(prop in next.props)) {
        this.removeAttribute(prop)
      }
    }

    this.props = next.props

    /*
      Keys are currently used to cache children, though could also be used
      to evaluate the need to replaceChild as later removeChild actually puts
      stuff in the right spot... but not sure if it really is necessary
    */

    let x = 0
    const mutations: any[] = []
    for (x; x < next.children.length; x++) {
      const prevChild = this.children[x]
      const nextChild = next.children[x]
      const nextChildCache = this.getCachedChild(nextChild)

      // Adding new item
      if (!prevChild) {
        const nextInstance =
          nextChildCache || nextChild.mount(this, this.context)

        mutations.push({
          type: 'append',
          child: nextInstance,
        })

        this.addKey(nextInstance)
        this.children[x] = nextInstance

        continue
      }

      // Is same cached items
      if (nextChildCache && prevChild === nextChildCache) {
        prevChild.reconcile(nextChild)

        continue
      }

      // Cached, but changed order
      if (nextChildCache && prevChild !== nextChildCache) {
        nextChildCache.reconcile(nextChild)

        const mutation = this.insertChild(nextChildCache, prevChild, x)

        mutation && mutations.push(mutation)

        this.children[x] = nextChildCache

        continue
      }

      // If same tag and no existing cached element
      if (!this.getCachedChild(prevChild) && prevChild.tag === nextChild.tag) {
        prevChild.reconcile(nextChild)

        continue
      }

      // We need to mount up and insert a new element
      nextChild.mount(this, this.context)
      const mutation = this.insertChild(nextChild, prevChild, x)
      mutation && mutations.push(mutation)
      this.addKey(nextChild)
      this.children[x] = nextChild
    }

    const remainingChildren = this.children.splice(x)

    for (let x = 0; x < remainingChildren.length; x++) {
      const child = remainingChildren[x]

      if (this.children.indexOf(child) >= 0) {
        continue
      }

      this.removeKey(child)

      const el = child.unmount().getElement()

      if (el) {
        mutations.push({
          type: 'remove',
          child,
        })
      }
    }

    mutations.forEach((mutation) => {
      const childEl = mutation.child.getElement()

      if (!childEl) {
        return
      }

      switch (mutation.type) {
        case 'append':
          this.el.appendChild(childEl)
          break
        case 'remove':
          this.el.removeChild(childEl)
          break
        case 'before':
          if (mutation.target) {
            this.el.insertBefore(childEl, mutation.target.getElement())
          } else {
            this.el.appendChild(childEl)
          }
          break
        case 'replace':
          this.el.replaceChild(childEl, mutation.target.getElement())
          break
      }
    })

    return this
  }
  insertChild(nextChild, prevChild, currentIndex) {
    const el = nextChild.getElement()
    const prevChildIndex = this.children.indexOf(prevChild)
    const prevChildHasBeenUsed =
      prevChildIndex >= 0 && prevChildIndex < currentIndex

    if (el && prevChildHasBeenUsed) {
      return {
        type: 'before',
        child: nextChild,
        target: this.getNextChildWithElement(this.children[currentIndex + 1]),
      }
    } else if (el && prevChild.isNull()) {
      return {
        type: 'before',
        child: nextChild,
        target: this.getNextChildWithElement(prevChild),
      }
    }
    if (el && prevChild.getElement()) {
      return {
        type: 'replace',
        child: nextChild,
        target: prevChild,
      }
    }
    if (el) {
      return {
        type: 'append',
        child: nextChild,
      }
    }

    if (prevChild.getElement()) {
      return {
        type: 'remove',
        child: prevChild,
      }
    }
  }
  getCachedChild(child) {
    return child && child.props && this.keys[child.props.key]
  }
  addKey(child) {
    if (child.props && 'key' in child.props) {
      this.keys[child.props.key] = child
    }
  }
  removeKey(child) {
    if (child.props && 'key' in child.props) {
      delete this.keys[child.props.key]
    }
  }
  reconcileChildComponent(component, prevChild, nextChild) {
    if (prevChild.tag === nextChild.tag) {
      prevChild.reconcile(nextChild)

      return prevChild
    } else {
      prevChild.unmount()
      nextChild.mount(component, component.context)
      const el = nextChild.getElement()
      if (el && prevChild.isNull()) {
        const insertBefore = this.getNextChildWithElement(component)
        this.el.insertBefore(el, insertBefore && insertBefore.getElement())
      } else if (el) {
        this.el.replaceChild(el, component.getElement())
      } else {
        this.el.removeChild(component.getElement())
      }

      return nextChild
    }
  }
  updateAttribute(attr, prevValue, nextValue) {
    if (this.context.events.isEventAttr(attr)) {
      this.context.events.register(
        attr.substr(2).toLowerCase(),
        this.el,
        nextValue
      )

      return
    }

    switch (attr) {
      case 'key':
        return
      case 'value':
        this.el.value = nextValue
        break
      case 'ref':
        nextValue(this.el)
        break
      case 'style':
        for (let key in nextValue) {
          if (!prevValue || prevValue[key] !== nextValue[key]) {
            this.el.style[key] = nextValue[key]
          }
        }

        if (prevValue) {
          for (let key in prevValue) {
            if (!(key in nextValue)) {
              this.el.style[key] = null
            }
          }
        }
        break
      case 'dangerouslySetInnerHTML':
        this.el.innerHTML = nextValue.__html
        break
      case 'className':
        this.el.setAttribute('class', nextValue)
        break
      default:
        this.el.setAttribute(attr, nextValue)
    }
  }
  removeAttribute(attr) {
    switch (attr) {
      case 'key':
        return
      case 'ref':
        return
      case 'style':
        this.el.style = null
        break
      case 'dangerouslySetInnerHTML':
        //
        break
      case 'className':
        this.el.removeAttribute('class')
        break
      default:
        this.el.removeAttribute(attr)
    }
  }
  getNextChildWithElement(child) {
    const index = this.children.indexOf(child) + 1

    for (let x = index; x < this.children.length; x++) {
      if (this.children[x].isNull()) {
        continue
      }

      return this.children[x]
    }

    return null
  }
  isNull() {
    return false
  }
  getElement() {
    return this.el
  }
  unmount() {
    this.isMounted = false
    for (let prop in this.props) {
      if (this.context.events.isEventAttr(this.props[prop])) {
        this.context.events.unregister(prop.substr(2).toLowerCase(), this.el)
      }
    }
    for (let x = 0; x < this.children.length; x++) {
      this.children[x].unmount()
    }

    return this
  }
}
