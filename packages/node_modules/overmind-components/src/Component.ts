import { Null } from './Null'

export type FormEvent<T> = {
  bubbles: boolean
  currentTarget: EventTarget & T
  cancelable: boolean
  defaultPrevented: boolean
  eventPhase: number
  isTrusted: boolean
  nativeEvent: Event
  preventDefault(): void
  isDefaultPrevented(): boolean
  stopPropagation(): void
  isPropagationStopped(): boolean
  persist(): void
  target: EventTarget
  timeStamp: number
  type: string
}

export class Component {
  tag: any
  props: any
  children: any
  hooks: any
  name: any
  componentId: any
  mutationListener: any
  componentInstanceId: any
  mountListeners: any
  unmountListeners: any
  reconcileListeners: any
  nextHookIndex: any
  parent: any
  context: any
  vtree: any
  isReconciling: any
  asyncRender: any
  static nextComponentId = 0
  static current
  constructor(tag, props, children) {
    this.tag = tag
    this.props = props || {}
    this.name = this.tag.name
    this.children = children
    this.hooks = []
    this.mountListeners = new Set()
    this.unmountListeners = new Set()
    this.reconcileListeners = new Set()
    this.nextHookIndex = 0
    this.componentId = this.tag.__componentId =
      typeof this.tag.__componentId === 'undefined'
        ? Component.nextComponentId++
        : this.tag.__componentId
    this.componentInstanceId = this.tag.__nextComponentInstanceId =
      typeof this.tag.__nextComponentInstanceId === 'undefined'
        ? 0
        : this.tag.__nextComponentInstanceId++
  }
  mount(parent, context) {
    this.parent = parent
    this.context = context

    const app = context.app
    const trackId = app.trackState()
    Component.current = this
    this.vtree =
      this.tag({
        ...this.props,
        children: this.children.length === 1 ? this.children[0] : this.children,
      }) || new Null()
    const paths = app.clearTrackState(trackId)
    this.mutationListener = app.addMutationListener(
      paths,
      (flushId, isAsync) => {
        app.eventHub.emitAsync('component:update', {
          componentId: this.componentId,
          componentInstanceId: this.componentInstanceId,
          name: this.name,
          flushId,
          paths: Array.from(paths),
        })

        if (isAsync && !this.asyncRender) {
          this.asyncRender = requestAnimationFrame(() => {
            this.asyncRender = null
            this.reconcile(this, true)
          })
        } else if (!isAsync) {
          cancelAnimationFrame(this.asyncRender)
          this.reconcile(this, true)
        }
      }
    )
    app.eventHub.emitAsync('component:add', {
      componentId: this.componentId,
      componentInstanceId: this.componentInstanceId,
      name: this.name,
      paths: Array.from(paths),
    })

    this.vtree.mount(this, this.context)
    for (const listener of this.mountListeners) {
      listener()
    }

    return this
  }
  addHook(hook) {
    if (this.hooks[this.nextHookIndex]) {
      this.hooks[this.nextHookIndex] = hook
      this.nextHookIndex++
      return
    }
    this.nextHookIndex = this.hooks.push(hook)
  }
  getHook() {
    return this.hooks[this.nextHookIndex]
  }
  hasChangedProps(propsA, propsB) {
    if ((propsA && !propsB) || (!propsA && propsB)) {
      return true
    }

    if (!propsA && !propsB) {
      return false
    }

    const propsAKeys = Object.keys(propsA)
    const propsBKeys = Object.keys(propsB)

    if (propsAKeys.length !== propsBKeys.length) {
      return true
    }

    for (let x = 0; x < propsBKeys.length; x++) {
      if (
        !(propsBKeys[x] in propsA) ||
        propsB[propsBKeys[x]] !== propsA[propsBKeys[x]]
      ) {
        return true
      }
    }

    return false
  }
  reconcile(next, force?) {
    if (this.isReconciling) {
      return
    }

    if (
      !force &&
      !this.hasChangedProps(this.props, next.props) &&
      !this.children.length &&
      !next.children.length
    ) {
      return
    }

    Component.current = this

    this.isReconciling = true
    this.nextHookIndex = 0
    this.children = next.children

    const app = this.context.app

    const trackId = app.trackState()
    const newVTree =
      this.tag({
        ...next.props,
        children: this.children.length === 1 ? this.children[0] : this.children,
      }) || new Null()
    const paths = app.clearTrackState(trackId)
    app.eventHub.emitAsync('component:update', {
      componentId: this.componentId,
      componentInstanceId: this.componentInstanceId,
      name: this.name,
      paths: Array.from(paths),
    })
    this.mutationListener.update(paths)
    for (const listener of this.reconcileListeners) {
      listener()
    }
    this.vtree = this.parent.reconcileChildComponent(this, this.vtree, newVTree)

    this.isReconciling = false

    return this.vtree
  }
  reconcileChildComponent(...args) {
    return this.parent.reconcileChildComponent(...args)
  }
  isNull() {
    return this.vtree instanceof Null
  }
  getElement() {
    return this.vtree.getElement()
  }
  getChild() {
    return this.vtree instanceof Component ? this.vtree.getChild() : this.vtree
  }
  unmount() {
    this.vtree.unmount()
    for (const listener of this.unmountListeners) {
      listener()
    }
    this.mutationListener.dispose()
    this.context.app.eventHub.emitAsync('component:remove', {
      componentId: this.componentId,
      componentInstanceId: this.componentInstanceId,
      name: this.name,
    })
    return this
  }
}
