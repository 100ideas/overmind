import { Overmind } from 'overmind'
import { testRender } from './testRender'
import { h } from './'
import { TComponent } from './Component'
import { Null } from './Null'

describe('COMPONENT', () => {
  test('should reconcile components', () => {
    const app = new Overmind({})
    const TestCompA = () => <div>foo</div>
    const TestCompB = () => <div>bar</div>
    const test = testRender(
      app,
      <div>
        <TestCompA />
      </div>
    )
    const target = test.getTargetElement()

    target.children[0].reconcile(
      <div>
        <TestCompB />
      </div>
    )

    expect(test.getUpdates().length).toBe(10)
    expect(target.children[0].children[0].vtree.children[0].el.nodeValue).toBe(
      'bar'
    )
  })
  test('should reconcile NULL components to component', () => {
    const app = new Overmind({})
    const TestCompA = () => null
    const TestCompB = () => <div>bar</div>
    const test = testRender(
      app,
      <div>
        <TestCompA />
      </div>
    )
    const target = test.getTargetElement()

    target.children[0].reconcile(
      <div>
        <TestCompB />
      </div>
    )

    expect(test.getUpdates().length).toBe(6)
    expect(target.children[0].children[0].vtree.children[0].el.nodeValue).toBe(
      'bar'
    )
  })
  test('should reconcile components to NULL component', () => {
    const app = new Overmind({})
    const TestCompA = () => <div>foo</div>
    const TestCompB = () => null
    const test = testRender(
      app,
      <div>
        <TestCompA />
      </div>
    )
    const target = test.getTargetElement()

    target.children[0].reconcile(
      <div>
        <TestCompB />
      </div>
    )

    expect(test.getUpdates().length).toBe(7)

    expect(target.children[0].children[0].vtree).toBeInstanceOf(Null)
  })
  test('should reconcile NULL components to NULL component', () => {
    const app = new Overmind({})
    const TestCompA = () => null
    const TestCompB = () => null
    const test = testRender(
      app,
      <div>
        <TestCompA />
      </div>
    )
    const target = test.getTargetElement()

    target.children[0].reconcile(
      <div>
        <TestCompB />
      </div>
    )

    console.log(test.getUpdates())
    expect(test.getUpdates().length).toBe(2)

    expect(target.children[0].children[0].vtree).toBeInstanceOf(Null)
  })
  test('should reconcile nested components from within', () => {
    const app = new Overmind({})
    let renderCount = 0
    const TestCompA = () => (renderCount++ ? <span>foo</span> : <div>bar</div>)
    const TestCompB = () => <TestCompA />
    const test = testRender(app, <TestCompB />)
    const target = test.getTargetElement()
    const testCompA = target.children[0].vtree

    testCompA.reconcile(testCompA, true)

    expect(test.getUpdates().length).toBe(8)
    expect(target.children[0].vtree.vtree.children[0].el.nodeValue).toBe('foo')
  })
  test('should update on state changes', () => {
    const app = new Overmind({
      state: {
        foo: true,
      },
      actions: {
        changeFoo({ state }) {
          state.foo = false
        },
      },
    })

    const TestComp: TComponent<typeof app> = ({ state }) =>
      state.foo ? <span>foo</span> : <div>bar</div>
    const test = testRender(app, <TestComp />)
    const target = test.getTargetElement()

    app.actions.changeFoo({})

    expect(test.getUpdates().length).toBe(8)

    expect(target.children[0].vtree.children[0].el.nodeValue).toBe('bar')
  })
})
