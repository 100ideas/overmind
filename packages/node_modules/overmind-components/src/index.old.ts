import { BaseApp } from 'overmind'

/*
  - Can not define elements outside of component and reuse in multiple renders
*/

const NULL = Symbol('NULL')
const LITERAL = Symbol('LITERAL')

let currentComponent

export type TComponent<App extends BaseApp, Props = {}, Children = any> = (
  props: {
    state: App['state']
    actions: App['actions']
    children?: Children
  } & Props
) => any

function isEventAttr(attr) {
  return (
    attr.length > 2 &&
    attr.substr(0, 2) === 'on' &&
    attr.substr(2, 1).toUpperCase() === attr.substr(2, 1)
  )
}

function hasChangedProps(propsA, propsB) {
  if ((propsA && !propsB) || (!propsA && propsB)) {
    return true
  }

  if (!propsA && !propsB) {
    return false
  }

  const propsAKeys = Object.keys(propsA)
  const propsBKeys = Object.keys(propsB)

  if (propsAKeys.length !== propsBKeys.length) {
    return true
  }

  for (let x = 0; x < propsBKeys.length; x++) {
    if (
      !(propsBKeys[x] in propsA) ||
      propsB[propsBKeys[x]] !== propsA[propsBKeys[x]]
    ) {
      return true
    }
  }

  return false
}

const events = {}

function registerEvent(type, element, cb) {
  if (!events[type]) {
    events[type] = new Map()
    document.addEventListener(type, (event) => {
      let node = event.target
      while (node.parentNode) {
        if (events[type].has(node)) {
          events[type].get(node)(event)
        }
        node = node.parentNode
      }
    })
  }

  events[type].set(element, cb)
}

function reconcile(prev, next) {
  if (prev.tag === next.tag) {
    return prev.reconcile(next)
  } else {
    return prev.parent.replaceChild(prev, next)
  }
}

function hasRemovedFromList(prevChild, nextChild, nextPrevChild) {
  return (
    prevChild &&
    nextChild &&
    nextPrevChild &&
    prevChild.props &&
    nextChild.props &&
    nextPrevChild.props &&
    prevChild.tag === nextChild.tag &&
    prevChild.props.key !== nextChild.props.key &&
    nextPrevChild.props.key === nextChild.props.key
  )
}

function hasAddedToList(prevChild, nextChild, nextNextChild) {
  return (
    prevChild &&
    nextChild &&
    nextNextChild &&
    prevChild.props &&
    nextChild.props &&
    nextNextChild.props &&
    prevChild.tag === nextChild.tag &&
    prevChild.props.key !== nextChild.props.key &&
    nextNextChild.props.key === prevChild.props.key
  )
}

function reconcileChildren(prev, next) {
  if (next.children) {
    for (let x = 0; x < next.children.length; x++) {
      const prevChild = prev.children[x]
      const nextChild = next.children[x]
      const nextPrevChild = prev.children[x + 1]
      const nextNextChild = next.children[x + 1]

      if (hasRemovedFromList(prevChild, nextChild, nextPrevChild)) {
        prev.removeChild(prevChild)
      } else if (hasAddedToList(prevChild, nextChild, nextNextChild)) {
        prev.insertChild(prevChild, nextChild)
      } else if (prevChild && nextChild && prevChild.tag === nextChild.tag) {
        reconcile(prevChild, nextChild)
      } else if (prevChild && nextChild) {
        prev.replaceChild(prevChild, nextChild)
      } else if (!prevChild && nextChild) {
        prev.insertChild(prevChild, nextChild)
      } else if (prevChild && !nextChild) {
        prev.removeChild(prevChild)
      }
    }
  }

  if (prev.children) {
    while (prev.children.length > next.children.length) {
      prev.children.pop().unmount(prev)
    }
  }
}

const baseOperations = {
  replaceChild(child, next) {
    const index = this.children.indexOf(child)
    this.children[index] = next
    const newEl = next.mount(this, this.app)
    if (child.el && newEl) {
      child.unmount()
      this.el.replaceChild(newEl, child.el)
    } else if (child.el) {
      child.unmount()
      this.el.removeChild(child.el)
    } else {
      this.el.appendChild(newEl)
    }

    return newEl
  },
  removeChild(child) {
    const index = this.children.indexOf(child)
    this.children[index] = Object.create(_null)
    this.children[index].mount(this, this.app)
    child.unmount()
    child.el && this.el.removeChild(child.el)
  },
  insertChild(child, next) {
    const index = this.children.indexOf(child)
    const el = next.mount(this, this.app)

    if (index === 0) {
      this.children.unshift(next)
      el && this.el.prepend(el)
    } else if (index === -1) {
      this.children.push(next)
      el && this.el.appendChild(el)
    } else {
      this.children.splice(index - 1, 0, next)
      el && this.el.insertBefore(child.el, el)
    }
  },
}

const _null = {
  ...baseOperations,
  tag: NULL,
  mount(parent, app) {
    this.parent = parent
    this.app = app
  },
  reconcile() {},
  unmount() {},
}

const literal = {
  tag: LITERAL,
  mount(parent) {
    this.parent = parent
    this.el = document.createTextNode(this.value)

    return this.el
  },
  reconcile(next) {
    if (this.value !== next.value) {
      this.value = next.value
      this.el.nodeValue = next.value
    }

    return this.el
  },
  unmount() {},
  toString() {
    return String(this.value)
  },
  valueOf() {
    return this.value
  },
}

const component = {
  nextComponentId: 0,
  mount(parent, app) {
    this.parent = parent
    this.app = app
    this.name = this.tag.name
    this.componentId = this.tag.__componentId =
      typeof this.tag.__componentId === 'undefined'
        ? 0
        : component.nextComponentId++
    this.componentInstanceId = this.tag.__nextComponentInstanceId =
      typeof this.tag.__nextComponentInstanceId === 'undefined'
        ? 0
        : this.tag.__nextComponentInstanceId + 1
    const trackId = app.trackState()
    currentComponent = this
    this.vtree =
      this.tag({
        ...this.props,
        state: app.state,
        actions: app.actions,
        children: this.children.length === 1 ? this.children[0] : this.children,
      }) || Object.create(_null)
    const paths = app.clearTrackState(trackId)
    this.listener = app.addMutationListener(paths, (flushId) => {
      app.eventHub.emitAsync('component:update', {
        componentId: this.componentId,
        componentInstanceId: this.componentInstanceId,
        name: this.name,
        flushId,
        paths: Array.from(paths),
      })
      this.reconcile(this, true)
    })
    app.eventHub.emitAsync('component:add', {
      componentId: this.componentId,
      componentInstanceId: this.componentInstanceId,
      name: this.name,
      paths: Array.from(paths),
    })
    this.el = this.vtree.mount(parent, app)
    for (const listener of this.mountListeners) {
      listener()
    }

    return this.el
  },
  reconcile(next, force) {
    if (this.isReconciling) {
      return
    }

    if (!force && !hasChangedProps(this.props, next.props)) {
      return
    }

    currentComponent = this

    this.isReconciling = true
    this.nextHookIndex = 0

    const trackId = this.app.trackState()
    const newVtree =
      this.tag({
        ...next.props,
        state: this.app.state,
        actions: this.app.actions,
        children: this.children.length === 1 ? this.children[0] : this.children,
      }) || Object.create(_null)
    const paths = this.app.clearTrackState(trackId)
    this.app.eventHub.emitAsync('component:update', {
      componentId: this.componentId,
      componentInstanceId: this.componentInstanceId,
      name: this.name,
      paths: Array.from(paths),
    })
    this.listener.update(paths)
    for (const listener of this.reconcileListeners) {
      listener()
    }
    this.el = reconcile(this.vtree, newVtree)

    this.props = next.props
    this.isReconciling = false

    return this.el
  },
  unmount(parent) {
    this.vtree.unmount(parent)
    for (const listener of this.unmountListeners) {
      listener()
    }
    this.listener.dispose()
    this.app.eventHub.emitAsync('component:remove', {
      componentId: this.componentId,
      componentInstanceId: this.componentInstanceId,
      name: this.name,
    })
  },
  addHook(hook) {
    if (this.hooks[this.nextHookIndex]) {
      this.hooks[this.nextHookIndex] = hook
      this.nextHookIndex++
      return
    }
    this.nextHookIndex = this.hooks.push(hook)
  },
  getHook() {
    return this.hooks[this.nextHookIndex]
  },
}

const element = {
  ...baseOperations,
  mount(parent, app) {
    this.parent = parent
    this.app = app
    this.el = document.createElement(this.tag)

    for (let x = 0; x < this.children.length; x++) {
      const el = this.children[x].mount(this, app)
      el && this.el.appendChild(el)
    }

    for (let prop in this.props) {
      this.updateAttribute(prop, this.props[prop])
    }

    if (this.props && this.props.ref) {
      this.props.ref(this.el)
    }

    return this.el
  },
  reconcile(next) {
    for (let prop in next.props) {
      if (this.props[prop] !== next.props[prop]) {
        this.updateAttribute(prop, next.props[prop])
      }
    }
    for (let prop in this.props) {
      if (!next.props || !(prop in next.props)) {
        this.removeAttribute(prop)
      }
    }

    this.props = next.props

    reconcileChildren(this, next)

    return this.el
  },
  updateAttribute(attr, value) {
    if (attr === 'ref') {
      
    } else if (isEventAttr(attr)) {
      registerEvent(attr.substr(2).toLowerCase(), this.el, value)
    } else if (attr === 'style') {
      for (let key in value) {
        this.el.style[key] = value[key]
      }
    } else if (attr === 'dangerouslySetInnerHTML') {
      this.el.innerHTML = value.__html
    } else if (attr === 'className') {
      this.el.setAttribute('class', value)
    } else {
      this.el.setAttribute(attr, value)
    }
  },
  removeAttribute(attr) {
    if (attr === 'ref') {
      
    } else if (isEventAttr(attr)) {
      // removeEvent(attr.substr(2).toLowerCase(), this.el, value)
    } else if (attr === 'style') {
      // ???
    } else if (attr === 'dangerouslySetInnerHTML') {
      //
    } else if (attr === 'className') {
      this.el.removeAttribute('class')
    } else {
      this.el.removeAttribute(attr)
    }
  },
  unmount() {
    for (let child of this.children) {
      child.unmount()
    }
  },
}

export function createElement(tag, props, ...children) {
  let instance
  if (typeof tag === 'function') {
    instance = Object.create(component)
    instance.hooks = []
    instance.mountListeners = new Set()
    instance.unmountListeners = new Set()
    instance.reconcileListeners = new Set()
    instance.nextHookIndex = 0
  } else {
    instance = Object.create(element)
  }

  instance.tag = tag
  instance.props = props
  instance.children = children.reduce((aggr, child) => {
    if (child === null) {
      return aggr.concat(Object.create(_null))
    } else if (typeof child !== 'object' && typeof child !== 'function') {
      const literalChild = Object.create(literal)
      literalChild.value = String(child)

      return aggr.concat(literalChild)
    } else if (Array.isArray(child)) {
      return aggr.concat(
        child.map((subChild) => {
          if (subChild === null) {
            return Object.create(_null)
          } else if (
            typeof subChild !== 'object' &&
            typeof subChild !== 'function'
          ) {
            const literalChild = Object.create(literal)
            literalChild.value = String(subChild)

            return literalChild
          }

          return subChild
        })
      )
    }

    return aggr.concat(child)
  }, [])

  return instance
}

export const h = createElement

export function render(app, source, target) {
  app.nextComponentId = 0
  const el = source.mount({ el: target }, app)
  el && target.appendChild(el)
}

export function useState(initialState) {
  const component = currentComponent
  const existingHook = component.getHook()

  if (existingHook) {
    component.nextHookIndex++
    return existingHook
  }

  const hook = [
    initialState,
    (newState) => {
      hook[0] = typeof newState === 'function' ? newState(hook[0]) : newState
      component.reconcile(component, true)
    },
  ]

  component.addHook(hook)

  return hook
}

export function useRef() {
  const existingHook = currentComponent.getHook()

  if (existingHook) {
    currentComponent.nextHookIndex++
    return existingHook
  }

  let hook = (node) => {
    ;(hook as any).target = node
  }

  currentComponent.addHook(hook)

  return hook
}

export function useEffect(effect, mem?) {
  const component = currentComponent
  const existingHook = component.getHook()

  if (existingHook) {
    existingHook.unsubscribe && existingHook.unsubscribe()
    component.mountListeners.delete(existingHook.updateListener)
    component.reconcileListeners.delete(existingHook.updateListener)
    component.unmountListeners.delete(existingHook.unmountListener)
  }

  const hook = {
    unsubscribe: () => {},
    updateListener:
      existingHook && mem
        ? () => {
            if (
              mem.reduce(
                (aggr, val, index) =>
                  aggr ? val === existingHook.mem[index] : false,
                true
              )
            ) {
              return
            }
            hook.unsubscribe = effect()
          }
        : () => {
            hook.unsubscribe = effect()
          },
    unmountListener: () => {
      hook.unsubscribe()
    },
    mem,
  }

  component.mountListeners.add(hook.updateListener)
  component.reconcileListeners.add(hook.updateListener)
  component.unmountListeners.add(hook.unmountListener)

  component.addHook(hook)
}

export function useRenderEffect(effect) {
  const existingListener = currentComponent.getHook()

  const updated = effect()
  const updateListener = () => updated()

  if (existingListener) {
    currentComponent.mountListeners.delete(existingListener)
    currentComponent.reconcileListeners.delete(existingListener)
    currentComponent.reconcileListeners.add(updateListener)
  } else {
    currentComponent.mountListeners.add(updateListener)
  }

  currentComponent.addHook(updateListener)
}

export function useCurrentComponent() {
  return currentComponent
}
