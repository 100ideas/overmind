import { Overmind } from 'overmind'
import { testRender } from './testRender'
import { h } from './'
import { useState, useEffect, useRef } from './hooks'

describe('HOOKS', () => {
  describe('STATE', () => {
    test('should render component with initial state', () => {
      const app = new Overmind({})
      const TestComponent = () => {
        const [state] = useState('foo')

        return <div>{state}</div>
      }
      const test = testRender(app, <TestComponent />)
      const target = test.getTargetElement()

      expect(target.children[0].vtree.children[0].el.nodeValue).toBe('foo')
    })
    test('should rerender component with new state', () => {
      const app = new Overmind({})
      const TestComponent = () => {
        const [state] = useState('foo')

        return <div>{state}</div>
      }
      const test = testRender(app, <TestComponent />)
      const target = test.getTargetElement()

      target.children[0].hooks[0][1]('bar')
      expect(target.children[0].vtree.children[0].el.nodeValue).toBe('bar')
    })
  })
  describe('EFFECT', () => {
    test('should run effect on initial render', () => {
      const app = new Overmind({})
      let hasRun = false
      const TestComponent = () => {
        useEffect(() => {
          hasRun = true
        })

        return null
      }
      testRender(app, <TestComponent />)

      expect(hasRun).toBe(true)
    })
    test('should rerun effect on new renders', () => {
      const app = new Overmind({})
      let runCount = 0
      const TestComponent = () => {
        useEffect(() => {
          runCount++
        })

        return null
      }
      const test = testRender(app, <TestComponent />)
      const component = test.getTargetElement().children[0]

      component.reconcile(component, true)
      expect(runCount).toBe(2)
    })
    test('should not rerun effect with empty array as second arg', () => {
      const app = new Overmind({})
      let runCount = 0
      const TestComponent = () => {
        useEffect(() => {
          runCount++
        }, [])

        return null
      }
      const test = testRender(app, <TestComponent />)
      const component = test.getTargetElement().children[0]

      component.reconcile(component, true)
      expect(runCount).toBe(1)
    })
    test('should not rerun effect with matching array', () => {
      const app = new Overmind({})
      let runCount = 0
      const TestComponent = () => {
        useEffect(
          () => {
            runCount++
          },
          ['foo']
        )

        return null
      }
      const test = testRender(app, <TestComponent />)
      const component = test.getTargetElement().children[0]

      component.reconcile(component, true)
      expect(runCount).toBe(1)
    })
    test('should rerun effect with non matching array', () => {
      const app = new Overmind({})
      let runCount = 0
      const TestComponent = () => {
        useEffect(
          () => {
            runCount++
          },
          [runCount]
        )

        return null
      }
      const test = testRender(app, <TestComponent />)
      const component = test.getTargetElement().children[0]

      component.reconcile(component, true)
      expect(runCount).toBe(2)
    })
  })
  describe('REF', () => {
    test.only('should provide element ref', () => {
      const app = new Overmind({})
      let providedRef
      const TestComponent = () => {
        const ref = useRef()
        providedRef = ref

        return <div ref={ref} />
      }
      testRender(app, <TestComponent />)

      expect(providedRef.target.tag).toBe('div')
    })
  })
})
