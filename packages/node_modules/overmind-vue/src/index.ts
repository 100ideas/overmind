import { TApp, EventType, Overmind, Configuration } from 'overmind'
import Vue, { ComponentOptions } from 'vue'

export type TConnect<Config extends Configuration> = {
  overmind: {
    state: TApp<Config>['state']
    actions: TApp<Config>['actions']
    reaction: (
      name: string,
      stateCb: (state: TApp<Config>['state']) => any,
      Function
    ) => void
  }
}

type DefaultData<V> = object | ((this: V) => object)
type DefaultProps = Record<string, any>
type DefaultMethods<V> = { [key: string]: (this: V, ...args: any[]) => any }
type DefaultComputed = { [key: string]: any }

let nextComponentId = 0

export const createConnect = <A extends Overmind<any>>(overmind: A) => <
  V extends Vue & A,
  Data extends DefaultData<V>,
  Methods extends DefaultMethods<V>,
  Computed extends DefaultComputed,
  PropsDef,
  Props extends DefaultProps
>(
  componentOptions: ComponentOptions<
    V,
    Data,
    Methods,
    Computed,
    PropsDef,
    Props
  >
): ComponentOptions<V, Data, Methods, Computed, PropsDef, Props> => {
  const componentId = nextComponentId++
  let componentInstanceId = 0
  const beforeMount = componentOptions.beforeMount
  const mounted = componentOptions.mounted
  const beforeDestroy = componentOptions.beforeDestroy

  // When mounting we start tracking paths being
  // used in the proxy-state-tree and attach
  // the state to the component as "store",
  // allowing templates to access it
  componentOptions.beforeMount = function() {
    this.__reactionFactory = overmind.createReactionFactory(
      this.name || this.displayName
    )
    this.__componentInstanceId = componentInstanceId++
    this.overmind = {
      state: overmind.state,
      actions: overmind.actions,
      reaction: this.__reactionFactory.add,
    }
    this.__trackId = overmind.trackState()
    beforeMount && beforeMount.call(this)
  }

  // When mounted we stop tracking paths and
  // subscribe to mutation changes, giving
  // a callback that runs whenever a mutation
  // matches the paths tracked on this component
  componentOptions.mounted = function() {
    const paths = overmind.clearTrackState(
      this.__trackId,
      mounted && mounted.bind(this)
    )
    overmind.eventHub.emitAsync(EventType.COMPONENT_ADD, {
      componentId,
      componentInstanceId: this.__componentInstanceId,
      name: componentOptions.name || this.name || '',
      paths: Array.from(paths),
    })
    this.__proxyStateTreeListener = overmind.addMutationListener(
      paths,
      (flushId) => {
        overmind.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
          componentId,
          componentInstanceId: this.__componentInstanceId,
          name: componentOptions.name || this.name || '',
          paths: Array.from(paths),
          flushId,
        })
        this.$forceUpdate()
      }
    )
    delete this.__trackId
    const nativeGetter = this._watcher.getter
    this._watcher.getter = () => {
      const trackId = overmind.trackState()
      nativeGetter.call(this, this)
      const paths = overmind.clearTrackState(trackId)
      this.__proxyStateTreeListener.update(paths)
      overmind.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
        componentId,
        componentInstanceId: this.__componentInstanceId,
        name: componentOptions.name || this.name || '',
        paths: Array.from(paths),
      })
    }
  }

  // When unmounting the component we dispose
  // of our listener
  componentOptions.beforeDestroy = function() {
    overmind.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
      componentId,
      componentInstanceId: this.__componentInstanceId,
      name: componentOptions.name || this.name || '',
    })

    this.__proxyStateTreeListener && this.__proxyStateTreeListener.dispose()
    this.__reactionFactory && this.__reactionFactory.dispose()
    beforeDestroy && beforeDestroy.call(this)
  }

  return componentOptions as any
}
