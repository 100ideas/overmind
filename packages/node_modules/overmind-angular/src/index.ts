import { EventType, Overmind, TApp, Configuration } from 'overmind'

// @ts-ignore
import { NgZone } from '@angular/core'

export type TConnect<Config extends Configuration> = {
  overmind: {
    state: TApp<Config>['state']
    actions: TApp<Config>['actions']
  }
}

let nextComponentId = 0

export const createConnect = <A extends Overmind<any>>(overmind: A) => () => {
  const componentId = nextComponentId++
  let componentInstanceId = 0

  return function(target: any) {
    const targetNgOnInit = target.prototype.ngOnInit
    const targetNgDoCheck = target.prototype.ngDoCheck
    const targetNgAfterContentInit = target.prototype.ngAfterContentInit
    const targetNgAfterViewInit = target.prototype.ngAfterViewInit
    const targetNgAfterViewChecked = target.prototype.ngAfterViewChecked

    target.prototype.ngOnInit = function() {
      const ngZ = new NgZone({ enableLongStackTrace: false })

      this.__tree = overmind.proxyStateTree.getTrackingTree()
      this.overmind = {
        state: this.__tree.state,
        actions: overmind.actions,
      }
      this.__shouldUpdatePaths = false
      this.__componentInstanceId = componentInstanceId++
      this.__onUpdate = () => {
        if (this.cdr) {
          this.cdr.markForCheck()
        }
        ngZ.run(() => {})
      }

      if (targetNgOnInit) {
        targetNgOnInit.apply(target)
      }

      if (
        !this.cdr &&
        (!target['__annotations__'][0] ||
          target['__annotations__'][0].changeDetection === 0)
      ) {
        throw new Error(
          'overmind-angular ERROR: You have to inject the ChangeDetectionRef as "cdr" on the component. In the constructor, add argument: "private cdr: ChangeDetectorRef" '
        )
      }
    }

    target.prototype.ngAfterContentInit = function() {
      this.__tree.track(this.__onUpdate)

      if (targetNgAfterContentInit) {
        targetNgAfterContentInit.apply(target)
      }
    }

    target.prototype.ngAfterViewInit = function() {
      overmind.eventHub.emitAsync(EventType.COMPONENT_ADD, {
        componentId,
        componentInstanceId: this.__componentInstanceId,
        name: this.constructor.name || '',
        paths: Array.from(this.__tree.pathDependencies),
      })

      if (targetNgAfterViewInit) {
        targetNgAfterViewInit.apply(target)
      }
    }

    target.prototype.ngDoCheck = function() {
      if (this.__shouldUpdatePaths) {
        this.__tree.track(this.__onUpdate)
      }
      if (targetNgDoCheck) {
        targetNgDoCheck.apply(target)
      }
    }

    target.prototype.ngAfterViewChecked = function() {
      if (this.__shouldUpdatePaths) {
        this.__shouldUpdatePaths = false
        overmind.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
          componentId,
          componentInstanceId: this.__componentInstanceId,
          name: this.constructor.name || '',
          paths: Array.from(this.__tree.pathDependencies),
          flushId,
        })
      }
      if (targetNgAfterViewChecked) {
        targetNgAfterViewChecked.apply(target)
      }
    }

    let targetNgOnDestroy = target.prototype.ngOnDestroy

    target.prototype.ngOnDestroy = function() {
      if (targetNgOnDestroy) {
        targetNgOnDestroy.apply(target)
      }
      overmind.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
        componentId,
        componentInstanceId: this.__componentInstanceId,
        name: this.constructor.name || '',
      })
      overmind.proxyStateTree.disposeTree(this.__tree)
    }

    return target
  }
}
