import { Operation } from 'overmind'
import {
  ActionGroupItem,
  ActionItem,
  ActionsListItemType,
  Message,
  Tab,
} from './types'
import {
  createApp,
  ensureFlushExists,
  getActionId,
  getOperatorId,
  runMutation,
} from './utils'

export const setPort: Operation.Mutate<string> = ({ state, value: port }) => {
  if (port) {
    state.port = port
  }
}

export const selectApp: Operation.Mutate<string> = ({
  state,
  value: appName,
}) => (state.currentAppName = appName)

export const setConnecting: Operation.Mutate = ({ state }) => {
  state.error = null
  state.isConnecting = true
}

export const setPortExists: Operation.Mutate = ({ state }) =>
  (state.error = 'PORT_EXISTS')

export const ensureCurrentApp: Operation.Mutate<Message> = ({
  state,
  value: message,
}) => {
  if (!state.currentAppName) {
    state.currentAppName = message.appName
  }
}

export const setError: Operation.Mutate<string> = ({ state, value: error }) =>
  (state.error = error)

export const setNewPortValue: Operation.Mutate<string> = ({ state, value }) =>
  (state.newPortValue = value)

export const resetNewPortValue: Operation.Mutate = ({ state }) =>
  (state.newPortValue = '')

export const addMessagesFromClient: Operation.Mutate<Message> = ({
  state,
  value: message,
}) =>
  (state.apps[message.appName].messages = message.messages
    .reverse()
    .concat(state.apps[message.appName].messages))

export const changeTab: Operation.Mutate<Tab> = ({ state, value: tab }) =>
  (state.currentTab = tab)

export const toggleExpandStatePath: Operation.Mutate<string[]> = ({
  state,
  value: path,
}) => {
  const pathString = path.join('.')

  if (state.expandedStatePaths.indexOf(pathString) >= 0) {
    state.expandedStatePaths.splice(
      state.expandedStatePaths.indexOf(pathString),
      1
    )
  } else {
    state.expandedStatePaths = state.expandedStatePaths.concat(pathString)
  }
}

export const performMutationsByMessageType: Operation.Mutate<Message> = ({
  state,
  value: message,
}) => {
  message.messages.forEach((clientMessage) => {
    if (clientMessage.type === 'PORT_EXISTS') {
      state.error = clientMessage.type

      return
    }

    switch (clientMessage.type) {
      case 'init': {
        state.isConnecting = false
        state.apps[message.appName] = createApp({
          name: message.appName,
          state: clientMessage.data.state,
        })
        break
      }
      case 'flush': {
        ensureFlushExists(
          state.apps[message.appName].flushes,
          clientMessage.data.flushId
        )
        state.apps[message.appName].flushes[
          clientMessage.data.flushId
        ].mutations =
          clientMessage.data.mutations

        if (typeof clientMessage.data.operatorId === 'undefined') {
          state.apps[message.appName].flushByActionId[
            getActionId(clientMessage.data)
          ] = {
            flushId: clientMessage.data.flushId,
            isCollapsed: true,
          }
        } else {
          state.apps[message.appName].flushByOperatorId[
            getOperatorId(clientMessage.data)
          ] = {
            flushId: clientMessage.data.flushId,
            isCollapsed: true,
          }
        }

        clientMessage.data.mutations.forEach(
          runMutation(state.apps[message.appName].state)
        )
        break
      }
      case 'component:add': {
        const id = `${clientMessage.data.componentId}_${
          clientMessage.data.componentInstanceId
        }`

        state.apps[message.appName].components[id] = {
          id,
          isMounted: true,
          updateCount: 0,
          ...clientMessage.data,
        }
        break
      }
      case 'component:update': {
        const id = `${clientMessage.data.componentId}_${
          clientMessage.data.componentInstanceId
        }`

        state.apps[message.appName].components[id].paths =
          clientMessage.data.paths

        if ('flushId' in clientMessage.data) {
          state.apps[message.appName].components[id].updateCount++

          ensureFlushExists(
            state.apps[message.appName].flushes,
            clientMessage.data.flushId
          )

          state.apps[message.appName].flushes[
            clientMessage.data.flushId
          ].components.push(id)
        }
        break
      }
      case 'component:remove': {
        const id = `${clientMessage.data.componentId}_${
          clientMessage.data.componentInstanceId
        }`

        state.apps[message.appName].components[id].isMounted = false
        break
      }
      case 'derived': {
        const appState = state.apps[message.appName].state
        const path = clientMessage.data.path.split('.')
        const key = path.pop()
        const target = path.reduce((aggr, pathKey) => aggr[pathKey], appState)
        target[key] = clientMessage.data.value

        state.apps[message.appName].derived[clientMessage.data.path] =
          clientMessage.data

        break
      }
      case 'derived:dirty': {
        ensureFlushExists(
          state.apps[message.appName].flushes,
          clientMessage.data.flushId
        )
        state.apps[message.appName].flushes[
          clientMessage.data.flushId
        ].derived.push(clientMessage.data.path)
        break
      }
      case 'reaction:update': {
        ensureFlushExists(
          state.apps[message.appName].flushes,
          clientMessage.data.flushId
        )

        state.apps[message.appName].flushes[
          clientMessage.data.flushId
        ].reactions.push(clientMessage.data.path)
        break
      }
      case 'action:start': {
        const app = state.apps[message.appName]
        const action = clientMessage.data
        const actionId = getActionId(action)
        const isSelectingFirstAction =
          !app.currentActionId || app.currentActionId === app.actionsList[0].id

        app.actions[actionId] = {
          ...action,
          isRunning: true,
          operators: [],
        }

        if (
          !app.actionsList.length ||
          app.actionsList[0].actionId !== action.actionId
        ) {
          app.actionsList.unshift({
            type: ActionsListItemType.ACTION,
            id: actionId,
            actionId: action.actionId,
          })
        } else if (app.actionsList[0].type === ActionsListItemType.ACTION) {
          const existingId = (app.actionsList[0] as ActionItem).id
          app.actionsList[0] = {
            type: ActionsListItemType.GROUP,
            id: getActionId(action),
            actionId: action.actionId,
            isCollapsed: true,
            actionIds: [actionId, existingId],
          }
        } else if (app.actionsList[0].type === ActionsListItemType.GROUP) {
          ;(app.actionsList[0] as ActionGroupItem).actionIds.unshift(actionId)
          ;(app.actionsList[0] as ActionGroupItem).id = actionId
        }

        if (isSelectingFirstAction) {
          app.currentActionId = actionId
        }
        break
      }
      case 'operator:start': {
        const operatorData = clientMessage.data
        const actionId = getActionId(operatorData)
        const action = state.apps[message.appName].actions[actionId]
        const operator = {
          ...operatorData,
          isRunning: true,
          isCollapsed: true,
          mutations: [],
          effects: [],
        }

        action.operators.push(operator)

        /*
          This ensures the order of operators, as actions composed with
          "parallel" operator can trigger operators sync/async, adding
          them in wrong order
        */
        const paths = new Map()
        action.operators.forEach((operator, index) => {
          const path = operator.path.length
            ? operator.path.join('.')
            : '__' + index
          if (paths.has(path)) {
            paths.get(path).push(operator)
          } else {
            paths.set(path, [operator])
          }
        })
        action.operators = Array.from(paths).reduce(
          (aggr, arr) => aggr.concat(arr[1]),
          []
        )
        break
      }
      case 'operator:end': {
        const operatorData = clientMessage.data
        const actionId = getActionId(operatorData)
        const action = state.apps[message.appName].actions[actionId]
        const operator = action.operators.find(
          (operator) => getOperatorId(operatorData) === getOperatorId(operator)
        )

        operator.isAsync = operatorData.isAsync
        operator.isRunning = false
        operator.result = operatorData.result
        break
      }
      case 'action:end': {
        const app = state.apps[message.appName]
        const action = clientMessage.data
        const id = `${action.actionId}_${action.executionId}`

        app.actions[id].isRunning = false
        break
      }
      case 'mutations': {
        const mutations = clientMessage.data
        const id = `${mutations.actionId}_${mutations.executionId}`
        const operator =
          state.apps[message.appName].actions[id].operators[
            mutations.operatorId
          ]

        operator.mutations = mutations.mutations
        break
      }
      case 'effect': {
        const effect = clientMessage.data
        const id = getActionId(effect)
        const operator =
          state.apps[message.appName].actions[id].operators[effect.operatorId]

        operator.effects.push(effect)
        break
      }
    }
  })
}

export const toggleActionItemCollapse: Operation.Mutate<string> = ({
  state,
  value: actionId,
}) => {
  for (let index in state.currentApp.actionsList) {
    const item = state.currentApp.actionsList[index]
    if (
      item.type === ActionsListItemType.GROUP &&
      item.id === actionId &&
      state.currentApp.currentActionId === actionId
    ) {
      item.isCollapsed = !item.isCollapsed
      break
    }
  }
}

export const selectAction: Operation.Mutate<string> = ({
  state,
  value: actionId,
}) => (state.currentApp.currentActionId = actionId)

type Collapse = {
  isCollapsed: boolean
}

export const toggleCollapsed: Operation.Mutate<Collapse> = ({
  value: item,
}) => {
  item.isCollapsed = !item.isCollapsed
}

export const toggleExpandAllActions: Operation.Mutate = ({ state }) =>
  (state.expandAllActionDetails = !state.expandAllActionDetails)

export const toggleGroupedComponent: Operation.Mutate<string> = ({
  state,
  value: name,
}) => {
  const index = state.expandedComponents.indexOf(name)
  if (index === -1) {
    state.expandedComponents.push(name)
  } else {
    state.expandedComponents.splice(index, 1)
  }
}
