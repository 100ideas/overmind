import { Mutate } from 'overmind'
import {
  Apps,
  Message,
  Tab,
  ActionsListItemType,
  ActionItem,
  ActionGroupItem,
} from './state'
import {
  runMutation,
  getActionId,
  createApp,
  ensureFlushExists,
  getOperatorId,
} from './utils'

export const setApps: Mutate<Apps> = (state, apps) => {
  if (!apps) {
    state.isAddingPort = true
  }

  state.apps = apps || {}
}

export const configurePort: Mutate = (state) => (state.isAddingPort = true)

export const selectPort: Mutate<string> = (state, port) =>
  (state.currentPort = port)

export const removeApp: Mutate = (state) => {
  delete state.apps[state.currentPort]

  const appPorts = Object.keys(state.apps)

  if (appPorts.length) {
    state.currentPort = appPorts[0]
  } else {
    state.isAddingPort = true
  }
}

export const cancelConfigurePort: Mutate = (state) =>
  (state.isAddingPort = false)

export const setCurrentPort: Mutate<string> = (state, currentPort) => {
  if (currentPort) {
    state.currentPort = currentPort
  } else if (Object.keys(state.apps).length) {
    state.currentPort = Object.keys(state.apps)[0]
  }
}

export const setError: Mutate<string> = (state, error) => (state.error = error)

export const setAppLoaded: Mutate = (state) => (state.isLoading = false)

export const setNewPortValue: Mutate<string> = (state, value) =>
  (state.newPortValue = value)

export const addNewApp: Mutate = (state) => {
  state.apps[state.newPortValue] = createApp({
    port: state.newPortValue,
  })
  state.isAddingPort = false
}

export const resetNewPortValue: Mutate = (state) => (state.newPortValue = '')

export const addMessagesFromClient: Mutate<Message> = (state, message) =>
  (state.apps[message.port].messages = message.message
    .reverse()
    .concat(state.apps[message.port].messages))

export const changeTab: Mutate<Tab> = (state, tab) => (state.currentTab = tab)

export const toggleExpandStatePath: Mutate<string[]> = (state, path) => {
  const pathString = path.join('.')

  if (state.expandedStatePaths.indexOf(pathString) >= 0) {
    state.expandedStatePaths.splice(
      state.expandedStatePaths.indexOf(pathString),
      1
    )
  } else {
    state.expandedStatePaths = state.expandedStatePaths.concat(pathString)
  }
}

export const performMutationsByMessageType: Mutate<Message> = (
  state,
  message
) => {
  message.message.forEach((clientMessage) => {
    switch (clientMessage.type) {
      case 'init': {
        state.apps[message.port] = createApp({
          port: message.port,
          state: clientMessage.data.state,
        })
        break
      }
      case 'flush': {
        ensureFlushExists(
          state.apps[message.port].flushes,
          clientMessage.data.flushId
        )
        state.apps[message.port].flushes[clientMessage.data.flushId].mutations =
          clientMessage.data.mutations

        if (typeof clientMessage.data.operatorId === 'undefined') {
          state.apps[message.port].flushByActionId[
            getActionId(clientMessage.data)
          ] = {
            flushId: clientMessage.data.flushId,
            isCollapsed: true,
          }
        } else {
          state.apps[message.port].flushByOperatorId[
            getOperatorId(clientMessage.data)
          ] = {
            flushId: clientMessage.data.flushId,
            isCollapsed: true,
          }
        }

        clientMessage.data.mutations.forEach(
          runMutation(state.apps[message.port].state)
        )
        break
      }
      case 'component:add': {
        const id = `${clientMessage.data.componentId}_${
          clientMessage.data.componentInstanceId
        }`

        state.apps[message.port].components[id] = {
          id,
          isMounted: true,
          updateCount: 0,
          ...clientMessage.data,
        }
        break
      }
      case 'component:update': {
        const id = `${clientMessage.data.componentId}_${
          clientMessage.data.componentInstanceId
        }`

        state.apps[message.port].components[id].paths = clientMessage.data.paths

        if ('flushId' in clientMessage.data) {
          state.apps[message.port].components[id].updateCount++

          ensureFlushExists(
            state.apps[message.port].flushes,
            clientMessage.data.flushId
          )

          state.apps[message.port].flushes[
            clientMessage.data.flushId
          ].components.push(id)
        }
        break
      }
      case 'component:remove': {
        const id = `${clientMessage.data.componentId}_${
          clientMessage.data.componentInstanceId
        }`

        state.apps[message.port].components[id].isMounted = false
        break
      }
      case 'derived': {
        const appState = state.apps[message.port].state
        const path = clientMessage.data.path.split('.')
        const key = path.pop()
        const target = path.reduce((aggr, pathKey) => aggr[pathKey], appState)
        target[key] = {
          paths: clientMessage.data.paths,
          updateCount: clientMessage.data.updateCount,
          value: clientMessage.data.value,
        }

        state.apps[message.port].derived[clientMessage.data.path] =
          clientMessage.data

        break
      }
      case 'derived:dirty': {
        ensureFlushExists(
          state.apps[message.port].flushes,
          clientMessage.data.flushId
        )
        state.apps[message.port].flushes[
          clientMessage.data.flushId
        ].derived.push(clientMessage.data.path)
        break
      }
      case 'computed': {
        const appState = state.apps[message.port].state
        const path = clientMessage.data.path.split('.')
        const key = path.pop()
        const target = path.reduce((aggr, pathKey) => aggr[pathKey], appState)
        target[key] = {
          cache: clientMessage.data.cache,
          limit: clientMessage.data.limit,
          updateCount: clientMessage.data.updateCount,
        }

        state.apps[message.port].computed[clientMessage.data.path] =
          clientMessage.data
        break
      }
      case 'computed:dirty': {
        ensureFlushExists(
          state.apps[message.port].flushes,
          clientMessage.data.flushId
        )
        state.apps[message.port].flushes[
          clientMessage.data.flushId
        ].computed.push(clientMessage.data.path)
        break
      }
      case 'action:start': {
        const app = state.apps[message.port]
        const action = clientMessage.data
        const actionId = getActionId(action)
        const isSelectingFirstAction =
          !app.currentActionId || app.currentActionId === app.actionsList[0].id

        app.actions[actionId] = {
          ...action,
          isRunning: true,
          operators: [],
        }

        if (
          !app.actionsList.length ||
          app.actionsList[0].actionId !== action.actionId
        ) {
          app.actionsList.unshift({
            type: ActionsListItemType.ACTION,
            id: actionId,
            actionId: action.actionId,
          })
        } else if (app.actionsList[0].type === ActionsListItemType.ACTION) {
          const existingId = (app.actionsList[0] as ActionItem).id
          app.actionsList[0] = {
            type: ActionsListItemType.GROUP,
            id: getActionId(action),
            actionId: action.actionId,
            isCollapsed: true,
            actionIds: [actionId, existingId],
          }
        } else if (app.actionsList[0].type === ActionsListItemType.GROUP) {
          ;(app.actionsList[0] as ActionGroupItem).actionIds.unshift(actionId)
          ;(app.actionsList[0] as ActionGroupItem).id = actionId
        }

        if (isSelectingFirstAction) {
          app.currentActionId = actionId
        }
        break
      }
      case 'operator:start': {
        const operatorData = clientMessage.data
        const actionId = getActionId(operatorData)
        const action = state.apps[message.port].actions[actionId]
        const operator = {
          ...operatorData,
          isRunning: true,
          isCollapsed: true,
          mutations: [],
          effects: [],
        }

        action.operators.push(operator)

        /*
          This ensures the order of operators, as actions composed with
          "parallel" operator can trigger operators sync/async, adding
          them in wrong order
        */
        const paths = new Map()
        action.operators.forEach((operator, index) => {
          const path = operator.path.length
            ? operator.path.join('.')
            : '__' + index
          if (paths.has(path)) {
            paths.get(path).push(operator)
          } else {
            paths.set(path, [operator])
          }
        })
        action.operators = Array.from(paths).reduce(
          (aggr, arr) => aggr.concat(arr[1]),
          []
        )
        break
      }
      case 'operator:end': {
        const operatorData = clientMessage.data
        const actionId = getActionId(operatorData)
        const action = state.apps[message.port].actions[actionId]
        const operator = action.operators.find(
          (operator) => getOperatorId(operatorData) === getOperatorId(operator)
        )

        operator.isAsync = operatorData.isAsync
        operator.isRunning = false
        operator.result = operatorData.result
        break
      }
      case 'action:end': {
        const app = state.apps[message.port]
        const action = clientMessage.data
        const id = `${action.actionId}_${action.executionId}`

        app.actions[id].isRunning = false
        break
      }
      case 'mutations': {
        const mutations = clientMessage.data
        const id = `${mutations.actionId}_${mutations.executionId}`
        const operator =
          state.apps[message.port].actions[id].operators[mutations.operatorId]

        operator.mutations = mutations.mutations
        break
      }
      case 'effect': {
        const effect = clientMessage.data
        const id = getActionId(effect)
        const operator =
          state.apps[message.port].actions[id].operators[effect.operatorId]

        operator.effects.push(effect)
        break
      }
    }
  })
}

export const toggleActionItemCollapse: Mutate<string> = (state, actionId) => {
  for (let index in state.currentApp.actionsList) {
    const item = state.currentApp.actionsList[index]
    if (
      item.type === ActionsListItemType.GROUP &&
      item.id === actionId &&
      state.currentApp.currentActionId === actionId
    ) {
      item.isCollapsed = !item.isCollapsed
      break
    }
  }
}

export const selectAction: Mutate<string> = (state, actionId) =>
  (state.currentApp.currentActionId = actionId)

type Collapse = {
  isCollapsed: boolean
}

export const toggleCollapsed: Mutate<Collapse> = (_, item) =>
  (item.isCollapsed = !item.isCollapsed)
