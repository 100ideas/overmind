import { Apps, State, Message, Tab } from './state'
import { runMutation } from './utils'

export const setApps = (state: State, apps: Apps) => (state.apps = apps || {})

export const setCurrentPort = (state: State, currentPort: string) => {
  if (currentPort) {
    state.currentPort = currentPort
  } else if (Object.keys(state.apps).length) {
    state.currentPort = Object.keys(state.apps)[0]
  }
}

export const setError = (state: State, error: string) => (state.error = error)

export const setAppLoaded = (state: State) => (state.isLoading = false)

export const setNewPortValue = (state: State, value: string) =>
  (state.newPortValue = value)

export const addNewApp = (state: State) =>
  (state.apps[state.newPortValue] = {
    name: null,
    port: state.newPortValue,
    messages: [],
    state: {},
    components: {},
    flushes: [
      {
        mutations: [],
        components: [],
      },
    ],
  })

export const resetNewPortValue = (state: State) => (state.newPortValue = '')

export const addMessagesFromClient = (state: State, message: Message) => {
  state.apps[message.port].messages = state.apps[message.port].messages.concat(
    message.message
  )
}

export const changeTab = (state: State, tab: Tab) => (state.currentTab = tab)

export const toggleExpandStatePath = (state: State, path: string[]) => {
  const pathString = path.join('.')

  if (state.expandedStatePaths.indexOf(pathString) >= 0) {
    state.expandedStatePaths.splice(
      state.expandedStatePaths.indexOf(pathString),
      1
    )
  } else {
    state.expandedStatePaths = state.expandedStatePaths.concat(pathString)
  }
}

export const performMutationsByMessageType = (
  state: State,
  message: Message
) => {
  message.message.forEach((clientMessage) => {
    switch (clientMessage.type) {
      case 'init': {
        state.apps[message.port] = {
          name: '',
          port: message.port,
          state: clientMessage.data.state,
          messages: [],
          components: {},
          flushes: [
            {
              mutations: [],
              components: [],
            },
          ],
        }
        break
      }
      case 'flush': {
        state.apps[message.port].flushes.push({
          mutations: clientMessage.data.mutations,
          components: [],
        })
        clientMessage.data.mutations.forEach(
          runMutation(state.apps[message.port].state)
        )
        break
      }
      case 'component:add': {
        const id = `${clientMessage.data.componentId}_${
          clientMessage.data.componentInstanceId
        }`

        state.apps[message.port].components[id] = {
          id,
          isMounted: true,
          updateCount: 0,
          ...clientMessage.data,
        }
        state.apps[message.port].flushes[
          state.apps[message.port].flushes.length - 1
        ].components.push(id)
        break
      }
      case 'component:update': {
        const id = `${clientMessage.data.componentId}_${
          clientMessage.data.componentInstanceId
        }`

        state.apps[message.port].components[id].paths = clientMessage.data.paths
        state.apps[message.port].components[id].updateCount++
        state.apps[message.port].flushes[
          state.apps[message.port].flushes.length - 1
        ].components.push(id)
        break
      }
      case 'component:remove': {
        const id = `${clientMessage.data.componentId}_${
          clientMessage.data.componentInstanceId
        }`

        state.apps[message.port].components[id].isMounted = false
        state.apps[message.port].flushes[
          state.apps[message.port].flushes.length - 1
        ].components.push(id)
        break
      }
      case 'derived': {
        const appState = state.apps[message.port].state
        const path = clientMessage.data.path.split('.')
        const key = path.pop()
        const target = path.reduce((aggr, pathKey) => aggr[pathKey], appState)
        target[key] = clientMessage.data.value
        break
      }
      case 'computed': {
        const appState = state.apps[message.port].state
        const path = clientMessage.data.path.split('.')
        const key = path.pop()
        const target = path.reduce((aggr, pathKey) => aggr[pathKey], appState)
        target[key] = clientMessage.data
        break
      }
    }
  })
}
