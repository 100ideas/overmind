import { mutate, forEach, fork, Operator, when, map, EventType } from 'overmind'
import {
  Message,
  AppMessage,
  InitMessage,
  FlushMessage,
  AddComponentMessage,
  UpdateComponentMessage,
  RemoveComponentMessage,
  DerivedMessage,
  DirtyDerivedMessage,
  ReactionUpdateMessage,
  ActionsListItemType,
  ActionItem,
  ActionGroupItem,
  StartActionMessage,
  StartOperatorMessage,
  EndOperatorMessage,
  EndActionMessage,
  MutationsMessage,
  EffectMessage,
  ExecutionType,
} from './types'
import {
  createApp,
  ensureFlushExists,
  getActionId,
  getOperatorId,
  runMutation,
} from './utils'

export const ensureCurrentApp = mutate<Message>(({ value: message, state }) => {
  if (!state.currentAppName) {
    state.currentAppName = message.appName
  }
})

export const setPortExists = mutate<any>(({ state }) => {
  state.error = 'PORT_EXISTS'
})

export const isPortExistsMessage = (paths: {
  true: Operator<Message, any>
  false: Operator<Message, any>
}) =>
  when(
    ({ value: message }) => message.messages[0].type === 'PORT_EXISTS',
    paths
  )

export const addState = mutate<InitMessage>(({ value: message, state }) => {
  state.isConnecting = false
  state.apps[message.appName].state = message.data.state
})

export const addFlushAndRunMutations = mutate<FlushMessage>(
  ({ value: message, state }) => {
    ensureFlushExists(state.apps[message.appName].flushes, message.data.flushId)
    state.apps[message.appName].flushes[message.data.flushId].mutations =
      message.data.mutations

    if (typeof message.data.operatorId === 'undefined') {
      state.apps[message.appName].flushByActionId[getActionId(message.data)] = {
        flushId: message.data.flushId,
      }
    } else {
      state.apps[message.appName].flushByOperatorId[
        getOperatorId(message.data)
      ] = {
        flushId: message.data.flushId,
      }
    }

    message.data.mutations.forEach(
      runMutation(state.apps[message.appName].state)
    )
  }
)

export const ensureApp = mutate<Message>(({ value: message, state }) => {
  if (
    !state.apps[message.appName] ||
    message.messages[0].type === ExecutionType.INIT
  ) {
    state.apps[message.appName] = createApp({
      name: message.appName,
    })
  }
})

export const addClientMessages = mutate<Message>(
  ({ value: message, state }) => {
    state.apps[message.appName].messages = message.messages
      .slice()
      .reverse()
      .concat(state.apps[message.appName].messages)
  }
)

export const addComponent = mutate<AddComponentMessage>(
  ({ value: message, state }) => {
    const id = `${message.data.componentId}_${message.data.componentInstanceId}`

    state.apps[message.appName].components[id] = {
      id,
      isMounted: true,
      updateCount: 0,
      name: message.data.name,
      paths: message.data.paths,
    }
  }
)

export const updateComponent = mutate<UpdateComponentMessage>(
  ({ value: message, state }) => {
    const id = `${message.data.componentId}_${message.data.componentInstanceId}`

    state.apps[message.appName].components[id].paths = message.data.paths

    if ('flushId' in message.data) {
      state.apps[message.appName].components[id].updateCount++

      ensureFlushExists(
        state.apps[message.appName].flushes,
        message.data.flushId
      )

      state.apps[message.appName].flushes[message.data.flushId].components.push(
        id
      )
    }
  }
)

export const removeComponent = mutate<RemoveComponentMessage>(
  ({ value: message, state }) => {
    const id = `${message.data.componentId}_${message.data.componentInstanceId}`

    state.apps[message.appName].components[id].isMounted = false
  }
)

export const updateDerived = mutate<DerivedMessage>(
  ({ value: message, state }) => {
    const appState = state.apps[message.appName].state
    const path = message.data.path.split('.')
    const key = path.pop()
    const target = path.reduce((aggr, pathKey) => aggr[pathKey], appState)
    target[key] = message.data.value

    state.apps[message.appName].derived[message.data.path] = message.data
  }
)

export const updateFlushWithDerived = mutate<DirtyDerivedMessage>(
  ({ value: message, state }) => {
    ensureFlushExists(state.apps[message.appName].flushes, message.data.flushId)
    state.apps[message.appName].flushes[message.data.flushId].derived.push(
      message.data.path
    )
  }
)

export const updateFlushWithReactionUpdate = mutate<ReactionUpdateMessage>(
  ({ value: message, state }) => {
    ensureFlushExists(state.apps[message.appName].flushes, message.data.flushId)

    state.apps[message.appName].flushes[message.data.flushId].reactions.push(
      message.data.path
    )
  }
)

export const addAction = mutate<StartActionMessage>(
  ({ value: message, state }) => {
    const app = state.apps[message.appName]
    const action = message.data
    const actionId = getActionId(action)
    const isSelectingFirstAction =
      !app.currentActionId || app.currentActionId === app.actionsList[0].id

    app.actions[actionId] = {
      ...action,
      isRunning: true,
      operators: [],
    }

    if (
      !app.actionsList.length ||
      app.actionsList[0].actionId !== action.actionId
    ) {
      app.actionsList.unshift({
        type: ActionsListItemType.ACTION,
        id: actionId,
        actionId: action.actionId,
      })
    } else if (app.actionsList[0].type === ActionsListItemType.ACTION) {
      const existingId = (app.actionsList[0] as ActionItem).id
      app.actionsList[0] = {
        type: ActionsListItemType.GROUP,
        id: getActionId(action),
        actionId: action.actionId,
        isCollapsed: true,
        actionIds: [actionId, existingId],
      }
    } else if (app.actionsList[0].type === ActionsListItemType.GROUP) {
      ;(app.actionsList[0] as ActionGroupItem).actionIds.unshift(actionId)
      ;(app.actionsList[0] as ActionGroupItem).id = actionId
    }

    if (isSelectingFirstAction) {
      app.currentActionId = actionId
    }
  }
)

export const addOperator = mutate<StartOperatorMessage>(
  ({ value: message, state }) => {
    const operatorData = message.data
    const actionId = getActionId(operatorData)
    const action = state.apps[message.appName].actions[actionId]
    const operator = {
      ...operatorData,
      isRunning: true,
      isCollapsed: true,
      mutations: [],
      effects: [],
    }

    action.operators.push(operator)

    /*
    This ensures the order of operators, as actions composed with
    "parallel" operator can trigger operators sync/async, adding
    them in wrong order
  */
    const paths = new Map()
    action.operators.forEach((operator, index) => {
      const path = operator.path.length ? operator.path.join('.') : '__' + index
      if (paths.has(path)) {
        paths.get(path).push(operator)
      } else {
        paths.set(path, [operator])
      }
    })
    action.operators = Array.from(paths).reduce(
      (aggr, arr) => aggr.concat(arr[1]),
      []
    )
  }
)

export const updateOperator = mutate<EndOperatorMessage>(
  ({ value: message, state }) => {
    const operatorData = message.data
    const actionId = getActionId(operatorData)
    const action = state.apps[message.appName].actions[actionId]
    const operator = action.operators.find(
      (operator) => getOperatorId(operatorData) === getOperatorId(operator)
    )

    operator.isAsync = operatorData.isAsync
    operator.isRunning = false
    operator.result = operatorData.result
  }
)

export const updateAction = mutate<EndActionMessage>(
  ({ value: message, state }) => {
    const app = state.apps[message.appName]
    const action = message.data
    const id = `${action.actionId}_${action.executionId}`

    app.actions[id].isRunning = false
  }
)

export const addMutations = mutate<MutationsMessage>(
  ({ value: message, state }) => {
    const mutations = message.data
    const id = `${mutations.actionId}_${mutations.executionId}`
    const operator =
      state.apps[message.appName].actions[id].operators[mutations.operatorId]

    operator.mutations = mutations.mutations
  }
)

export const addEffect = mutate<EffectMessage>(({ value: message, state }) => {
  const effect = message.data
  const id = getActionId(effect)
  const operator =
    state.apps[message.appName].actions[id].operators[effect.operatorId]

  operator.effects.push(effect)
})

export const getMessages = map<Message, AppMessage<any>[]>(({ value }) =>
  value.messages.map((message) => ({ ...message, appName: value.appName }))
)

export const forkEachMessage = (paths: {
  [key: string]: Operator<AppMessage<any>, AppMessage<any>>
}) => forEach<AppMessage<any>[]>(fork(({ value }) => value.type, paths))
